<!DOCTYPE html>
<!-- saved from url=(0032)http://nodejs.cn/api/stream.html -->
<html lang="zh-cmn-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>stream | Node.js API 文档</title>
  <link rel="stylesheet" href="res/api.css">
</head>
<body class="alt apidoc" id="api-section-stream">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="http://nodejs.cn/">
          Node.js 中文网
        </a>
        <!--<div>
          <input placeholder="快速搜索" id="search_input">
        </div>-->
      </div>
      <ul>
<li><a class="nav-documentation" href="documentation.html">关于本文档</a></li>
<li><a class="nav-synopsis" href="synopsis.html">用法与例子</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a class="nav-assert" href="assert.html">Assert (断言)</a></li>
<li><a class="nav-buffer" href="buffer.html">Buffer</a></li>
<li><a class="nav-addons" href="addons.html">C/C++ 插件</a></li>
<li><a class="nav-child_process" href="child_process.html">Child Processes (子进程)</a></li>
<li><a class="nav-cluster" href="cluster.html">Cluster (集群)</a></li>
<li><a class="nav-cli" href="cli.html">CLI (命令行选项)</a></li>
<li><a class="nav-console" href="console.html">Console (控制台)</a></li>
<li><a class="nav-crypto" href="crypto.html">Crypto (加密)</a></li>
<li><a class="nav-debugger" href="debugger.html">Debugger (调试器)</a></li>
<li><a class="nav-dns" href="dns.html">DNS (域名服务器)</a></li>
<li><a class="nav-domain" href="domain.html">Domain (域)</a></li>
<li><a class="nav-errors" href="errors.html">Error (错误)</a></li>
<li><a class="nav-events" href="events.html">Events (事件)</a></li>
<li><a class="nav-fs" href="fs.html">File System (文件系统)</a></li>
<li><a class="nav-globals" href="globals.html">Global (全局变量)</a></li>
<li><a class="nav-http" href="http.html">HTTP</a></li>
<li><a class="nav-https" href="https.html">HTTPS</a></li>
<li><a class="nav-modules" href="modules.html">Module (模块)</a></li>
<li><a class="nav-net" href="net.html">Net (网络)</a></li>
<li><a class="nav-os" href="os.html">OS (操作系统)</a></li>
<li><a class="nav-path" href="path.html">Path (路径)</a></li>
<li><a class="nav-process" href="process.html">Process (进程)</a></li>
<li><a class="nav-punycode" href="punycode.html">Punycode</a></li>
<li><a class="nav-querystring" href="querystring.html">Query Strings (查询字符串)</a></li>
<li><a class="nav-readline" href="readline.html">Readline (逐行读取)</a></li>
<li><a class="nav-repl" href="repl.html">REPL (交互式解释器)</a></li>
<li><a class="nav-stream active" href="./stream_files/stream.htm">Stream (流)</a></li>
<li><a class="nav-string_decoder" href="string_decoder.html">String Decoder (字符串解码器)</a></li>
<li><a class="nav-timers" href="timers.html">Timer (定时器)</a></li>
<li><a class="nav-tls" href="tls.html">TLS/SSL</a></li>
<li><a class="nav-tty" href="tty.html">TTY (终端)</a></li>
<li><a class="nav-dgram" href="dgram.html">UDP/Datagram (数据报)</a></li>
<li><a class="nav-url" href="url.html">URL</a></li>
<li><a class="nav-util" href="util.html">Util (实用工具)</a></li>
<li><a class="nav-v8" href="v8.html">V8</a></li>
<li><a class="nav-vm" href="vm.html">VM (虚拟机)</a></li>
<li><a class="nav-zlib" href="zlib.html">ZLIB (压缩)</a></li>
</ul>
<div class="line"></div>


    </div>

    <div id="column1" data-id="stream" class="interior">
      <header>
        <h1>Node.js v6.10.2 文档</h1>
        <div id="gtoc">
          <p>
            <a href="" name="toc">返回文档首页</a>
            <!--<a href="/api/all.html">单页面显示</a> |-->
            <!--<a href="/api/stream.json">JSON格式</a> |-->
            <!--<a href="/api/en/stream.html">查看英文版</a>-->
          </p>
        </div>
        <hr>
      </header>

      <div id="toc">
        <h2>目录</h2>
        <ul>
<li><span class="stability_2"><a href="stream.html#stream_stream">stream (流)</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_organization_of_this_document">本文档的组织</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_types_of_streams">流的类型</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_object_mode">对象模式</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_buffering">缓冲</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_api_for_stream_consumers">流消费者的 API</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_streams">可写流</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_class_stream_writable">stream.Writable 类</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_event_close">'close' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_drain">'drain' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_error">'error' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_finish">'finish' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_pipe">'pipe' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_unpipe">'unpipe' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_cork">writable.cork()</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_end_chunk_encoding_callback">writable.end([chunk][, encoding][, callback])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_setdefaultencoding_encoding">writable.setDefaultEncoding(encoding)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_uncork">writable.uncork()</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_write_chunk_encoding_callback">writable.write(chunk[, encoding][, callback])</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_streams">可读流</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_two_modes">两种模式</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_three_states">三种状态</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_choose_one">选择一种</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_class_stream_readable">stream.Readable 类</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_event_close_1">'close' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_data">'data' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_end">'end' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_error_1">'error' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_event_readable">'readable' 事件</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_ispaused">readable.isPaused()</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_pause">readable.pause()</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_pipe_destination_options">readable.pipe(destination[, options])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_read_size">readable.read([size])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_resume">readable.resume()</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_setencoding_encoding">readable.setEncoding(encoding)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_unpipe_destination">readable.unpipe([destination])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_unshift_chunk">readable.unshift(chunk)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_wrap_stream">readable.wrap(stream)</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_duplex_and_transform_streams">Duplex 流与 Transform 流</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_class_stream_duplex">stream.Duplex 类</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_class_stream_transform">stream.Transform 类</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_api_for_stream_implementers">API for Stream Implementers</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_simplified_construction">Simplified Construction</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_implementing_a_writable_stream">Implementing a Writable Stream</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_constructor_new_stream_writable_options">Constructor: new stream.Writable([options])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">writable._write(chunk, encoding, callback)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_writable_writev_chunks_callback">writable._writev(chunks, callback)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_errors_while_writing">Errors While Writing</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_an_example_writable_stream">一个可写流的例子</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_implementing_a_readable_stream">Implementing a Readable Stream</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_new_stream_readable_options">new stream.Readable([options])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_read_size_1">readable._read(size)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_push_chunk_encoding">readable.push(chunk[, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_errors_while_reading">Errors While Reading</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_an_example_counting_stream">一个数流的例子</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_implementing_a_duplex_stream">Implementing a Duplex Stream</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_new_stream_duplex_options">new stream.Duplex(options)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_an_example_duplex_stream">An Example Duplex Stream</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_object_mode_duplex_streams">Object Mode Duplex Streams</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_implementing_a_transform_stream">Implementing a Transform Stream</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_new_stream_transform_options">new stream.Transform([options])</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_events_finish_and_end">Events: 'finish' and 'end'</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_transform_flush_callback">transform._flush(callback)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_transform_transform_chunk_encoding_callback">transform._transform(chunk, encoding, callback)</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_class_stream_passthrough">Class: stream.PassThrough</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="stability_undefined"><a href="stream.html#stream_additional_notes">Additional Notes</a></span><ul>
<li><span class="stability_undefined"><a href="stream.html#stream_compatibility_with_older_node_js_versions">Compatibility with Older Node.js Versions</a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_read_0"><code>readable.read(0)</code></a></span></li>
<li><span class="stability_undefined"><a href="stream.html#stream_readable_push"><code>readable.push('')</code></a></span></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>

      <div id="apicontent">
        <h1>stream (流)<span><a class="mark" href="stream.html#stream_stream" id="stream_stream">#</a></span></h1><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/stream.md">参与翻译</a></p>
<pre class="api_stability api_stability_2 sh_sourceCode">稳定性<span class="sh_symbol">:</span> <span class="sh_number">2</span> <span class="sh_symbol">-</span> 稳定的</pre><p>流（stream）在 Node.js 中是处理流数据的抽象接口（abstract interface）。
<code>stream</code> 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。</p>
<p>Node.js 提供了多种流对象。 例如，
<a href="http.html#http_class_http_incomingmessage">HTTP 请求</a> 和 <a href="process.html#process_process_stdout"><code>process.stdout</code></a>
就都是流的实例。</p>
<p>流可以是可读的、可写的，或是可读写的。所有的流都是
<a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> 的实例。</p>
<p><code>stream</code> 模块可以通过以下方式引入：</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> stream <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">);</span>
</code></pre>
<p>尽管所有的 Node.js 用户都应该理解流的工作方式，这点很重要，
但是 <code>stream</code> 模块本身只对于那些需要创建新的流的实例的开发者最有用处。 对于主要是 <em>消费</em> 流的开发者来说，他们很少（如果有的话）需要直接使用
 <code>stream</code> 模块。</p>
<h2>本文档的组织<span><a class="mark" href="stream.html#stream_organization_of_this_document" id="stream_organization_of_this_document">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_organization_of_this_document">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/organization_of_this_document.md">参与翻译</a></p>
<p>本文档主要分为两节，第三节是一些额外的注意事项。第一节阐述了在应用中和 <em>使用</em> 流相关的 API 。 第二节阐述了和 <em>实现</em> 新的流类型相关的 API 。</p>
<h2>流的类型<span><a class="mark" href="stream.html#stream_types_of_streams" id="stream_types_of_streams">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_types_of_streams">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/types_of_streams.md">参与翻译</a></p>
<p>Node.js 中有四种基本的流类型：</p>
<ul>
<li><a href="stream.html#stream_class_stream_readable">Readable</a> - 可读的流 (例如
<a href="fs.html#fs_fs_createreadstream_path_options"><code>fs.createReadStream()</code></a>).</li>
<li><a href="stream.html#stream_class_stream_writable">Writable</a> - 可写的流 (例如
<a href="fs.html#fs_fs_createwritestream_path_options"><code>fs.createWriteStream()</code></a>).</li>
<li><a href="stream.html#stream_class_stream_duplex">Duplex</a> - 可读写的流 (例如
<a href="net.html#net_class_net_socket"><code>net.Socket</code></a>).</li>
<li><a href="stream.html#stream_class_stream_transform">Transform</a> - 在读写过程中可以修改和变换数据的 Duplex 流  (例如 <a href="zlib.html#zlib_zlib_createdeflate_options"><code>zlib.createDeflate()</code></a>).</li>
</ul>
<h3>对象模式<span><a class="mark" href="stream.html#stream_object_mode" id="stream_object_mode">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_object_mode">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/object_mode.md">参与翻译</a></p>
<p>所有使用 Node.js API 创建的流对象都只能操作 strings 和 <code>Buffer</code>
对象。但是，通过一些第三方流的实现，你依然能够处理其它类型的 JavaScript 值 (除了 <code>null</code>，它在流处理中有特殊意义)。 这些流被认为是工作在 “对象模式”（object mode）。</p>
<p>在创建流的实例时，可以通过 <code>objectMode</code> 选项使流的实例切换到对象模式。试图将已经存在的流切换到对象模式是不安全的。</p>
<h3>缓冲<span><a class="mark" href="stream.html#stream_buffering" id="stream_buffering">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_buffering">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/buffering.md">参与翻译</a></p>
<!--type=misc-->
<p><a href="stream.html#stream_class_stream_writable">Writable</a> 和 <a href="stream.html#stream_class_stream_readable">Readable</a> 流都会将数据存储到内部的缓存（buffer）中。这些缓存可以
通过相应的 <code>writable._writableState.getBuffer()</code> 或
<code>readable._readableState.buffer</code>来获取。</p>
<p>缓存的大小取决于传递给流构造函数的 <code>highWaterMark</code> 选项。
对于普通的流， <code>highWaterMark</code>
选项指定了总共的字节数。对于工作在对象模式的流，
<code>highWaterMark</code> 指定了对象的总数。</p>
<p>当可读流的实现调用 
<a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a> 方法时，数据被放到缓存中。如果流的消费者
没有调用 <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 方法， 这些数据会始终存在于内部队列中，直到被消费。</p>
<p>当内部可读缓存的大小达到 <code>highWaterMark</code> 指定的阈值时，流会暂停从底层资源读取数据，直到当前
缓存的数据被消费 (也就是说，
流会在内部停止调用 <code>readable._read()</code> 来填充可读缓存)。</p>
<p>可写流通过反复调用
<a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> 方法将数据放到缓存。
当内部可写缓存的总大小小于
<code>highWaterMark</code> 指定的阈值时， 调用 <code>writable.write()</code> 将返回<code>true</code>。 
一旦内部缓存的大小达到或超过 <code>highWaterMark</code> ，调用 <code>writable.write()</code> 将返回 <code>false</code> 。</p>
<p><code>stream</code> API 的关键目标， 尤其对于 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> 方法，
就是限制缓存数据大小，以达到可接受的程度。这样，对于读写速度不匹配的源头和目标，就不会超出可用的内存大小。</p>
<p><a href="stream.html#stream_class_stream_duplex">Duplex</a> 和 <a href="stream.html#stream_class_stream_transform">Transform</a> 都是可读写的。
在内部，它们都维护了 <em>两个</em> 相互独立的缓存用于读和写。
在维持了合理高效的数据流的同时，也使得对于读和写可以独立进行而互不影响。
例如， <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 就是 <a href="stream.html#stream_class_stream_duplex">Duplex</a> 的实例，它的可读端可以消费从套接字（socket）中接收的数据， 
可写端则可以将数据写入到套接字。
由于数据写入到套接字中的速度可能比从套接字接收数据的速度快或者慢，
在读写两端使用独立缓存，并进行独立操作就显得很重要了。</p>
<h2>流消费者的 API<span><a class="mark" href="stream.html#stream_api_for_stream_consumers" id="stream_api_for_stream_consumers">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_api_for_stream_consumers">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/api_for_stream_consumers.md">参与翻译</a></p>
<!--type=misc-->
<p>几乎所有的 Node.js 应用，不管多么简单，都在某种程度上使用了流。
下面是在 Node.js 应用中使用流实现的一个简单的 HTTP 服务器：</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> http <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'http'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">const</span> server <span class="sh_symbol">=</span> http<span class="sh_symbol">.</span><span class="sh_function">createServer</span><span class="sh_symbol">(</span> <span class="sh_symbol">(</span>req<span class="sh_symbol">,</span> res<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_comment">// req 是 http.IncomingMessage 的实例，这是一个 Readable Stream</span>
  <span class="sh_comment">// res 是 http.ServerResponse 的实例，这是一个 Writable Stream</span>

  let body <span class="sh_symbol">=</span> <span class="sh_string">''</span><span class="sh_symbol">;</span>
  <span class="sh_comment">// 接收数据为 utf8 字符串，</span>
  <span class="sh_comment">// 如果没有设置字符编码，将接收到 Buffer 对象。</span>
  req<span class="sh_symbol">.</span><span class="sh_function">setEncoding</span><span class="sh_symbol">(</span><span class="sh_string">'utf8'</span><span class="sh_symbol">);</span>

  <span class="sh_comment">// 如果监听了 'data' 事件，Readable streams 触发 'data' 事件 </span>
  req<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
    body <span class="sh_symbol">+=</span> chunk<span class="sh_symbol">;</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

  <span class="sh_comment">// end 事件表明整个 body 都接收完毕了 </span>
  req<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">try</span> <span class="sh_cbracket">{</span>
      <span class="sh_keyword">const</span> data <span class="sh_symbol">=</span> JSON<span class="sh_symbol">.</span><span class="sh_function">parse</span><span class="sh_symbol">(</span>body<span class="sh_symbol">);</span>
      <span class="sh_comment">// 发送一些信息给用户</span>
      res<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_keyword">typeof</span> data<span class="sh_symbol">);</span>
      res<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">();</span>
    <span class="sh_cbracket">}</span> <span class="sh_keyword">catch</span> <span class="sh_symbol">(</span>er<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
      <span class="sh_comment">// json 数据解析失败 </span>
      res<span class="sh_symbol">.</span>statusCode <span class="sh_symbol">=</span> <span class="sh_number">400</span><span class="sh_symbol">;</span>
      <span class="sh_keyword">return</span> res<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span>`error<span class="sh_symbol">:</span> $<span class="sh_cbracket">{</span>er<span class="sh_symbol">.</span>message<span class="sh_cbracket">}</span>`<span class="sh_symbol">);</span>
    <span class="sh_cbracket">}</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

server<span class="sh_symbol">.</span><span class="sh_function">listen</span><span class="sh_symbol">(</span><span class="sh_number">1337</span><span class="sh_symbol">);</span>

<span class="sh_comment">// $ curl localhost:1337 -d '{}'</span>
<span class="sh_comment">// object</span>
<span class="sh_comment">// $ curl localhost:1337 -d '"foo"'</span>
<span class="sh_comment">// string</span>
<span class="sh_comment">// $ curl localhost:1337 -d 'not json'</span>
<span class="sh_comment">// error: Unexpected token o</span>
</code></pre>
<p><a href="stream.html#stream_class_stream_writable">Writable</a> 流 (比如例子中的 <code>res</code>) 暴露了一些方法，比如
<code>write()</code> 和 <code>end()</code> 。这些方法可以将数据写入到流中。</p>
<p>当流中的数据可以读取时，<a href="stream.html#stream_class_stream_readable">Readable</a> 流使用 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> API 来通知应用。
这些数据可以使用多种方法从流中读取。</p>
<p><a href="stream.html#stream_class_stream_writable">Writable</a> 和 <a href="stream.html#stream_class_stream_readable">Readable</a> 流都使用了 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> API ，通过多种方式，
与流的当前状态进行交互。</p>
<p><a href="stream.html#stream_class_stream_duplex">Duplex</a> 和 <a href="stream.html#stream_class_stream_transform">Transform</a> 都是同时满足 <a href="stream.html#stream_class_stream_writable">Writable</a> 和 <a href="stream.html#stream_class_stream_readable">Readable</a> 。</p>
<p>对于只是简单写入数据到流和从流中消费数据的应用来说，
不要求直接实现流接口，通常也不需要调用 <code>require('stream')</code>。</p>
<p>需要实现两种类型流的开发者可以参考 <a href="stream.html#stream_api_for_stream_implementers">API for Stream Implementers</a>。</p>
<h3>可写流<span><a class="mark" href="stream.html#stream_writable_streams" id="stream_writable_streams">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_streams">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_streams.md">参与翻译</a></p>
<p>Writable streams 是 <em>destination</em> 的一种抽象，这种 <em>destination</em> 允许数据写入。</p>
<p><a href="stream.html#stream_class_stream_writable">Writable</a> 的例子包括了：</p>
<ul>
<li><a href="http.html#http_class_http_clientrequest">HTTP requests, on the client</a></li>
<li><a href="http.html#http_class_http_serverresponse">HTTP responses, on the server</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="process.html#process_process_stdout"><code>process.stdout</code></a>, <a href="process.html#process_process_stderr"><code>process.stderr</code></a></li>
</ul>
<p><em>注意</em>: 上面的某些例子事实上是 <a href="stream.html#stream_class_stream_duplex">Duplex</a> 流，只是实现了 <a href="stream.html#stream_class_stream_writable">Writable</a> 接口。</p>
<p>所有 <a href="stream.html#stream_class_stream_writable">Writable</a> 流都实现了
<code>stream.Writable</code> 类定义的接口。</p>
<p>尽管特定的 <a href="stream.html#stream_class_stream_writable">Writable</a> 流的实现可能略有差别，
所有的 Writable streams 都可以按一种基本模式进行使用，如下面例子所示：</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> myStream <span class="sh_symbol">=</span> <span class="sh_function">getWritableStreamSomehow</span><span class="sh_symbol">();</span>
myStream<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'some data'</span><span class="sh_symbol">);</span>
myStream<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'some more data'</span><span class="sh_symbol">);</span>
myStream<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span><span class="sh_string">'done writing data'</span><span class="sh_symbol">);</span>
</code></pre>
<h4>stream.Writable 类<span><a class="mark" href="stream.html#stream_class_stream_writable" id="stream_class_stream_writable">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_class_stream_writable">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/class_stream_writable.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><!--type=class-->
<h5>'close' 事件<span><a class="mark" href="stream.html#stream_event_close" id="stream_event_close">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_close">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_close.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><p><code>'close'</code> 事件将在流或其底层资源（比如一个文件）关闭后触发。<code>'close'</code> 事件触发后，该流将不会再触发任何事件。</p>
<p>不是所有可写流都会触发 <code>'close'</code> 事件。</p>
<h5>'drain' 事件<span><a class="mark" href="stream.html#stream_event_drain" id="stream_event_drain">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_drain">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_drain.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><p>如果调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> 方法返回 <code>false</code>，流将在适当的时机触发
<code>'drain'</code> 事件，这时才可以继续向流中写入数据。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_comment">// 向可写流中写入数据一百万次。</span>
<span class="sh_comment">// 需要注意背压 （back-pressure）。</span>
<span class="sh_keyword">function</span> <span class="sh_function">writeOneMillionTimes</span><span class="sh_symbol">(</span>writer<span class="sh_symbol">,</span> data<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  let i <span class="sh_symbol">=</span> <span class="sh_number">1000000</span><span class="sh_symbol">;</span>
  <span class="sh_function">write</span><span class="sh_symbol">();</span>
  <span class="sh_keyword">function</span> <span class="sh_function">write</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">var</span> ok <span class="sh_symbol">=</span> <span class="sh_keyword">true</span><span class="sh_symbol">;</span>
    <span class="sh_keyword">do</span> <span class="sh_cbracket">{</span>
      i<span class="sh_symbol">--;</span>
      <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>i <span class="sh_symbol">===</span> <span class="sh_number">0</span><span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
        <span class="sh_comment">// 最后 一次</span>
        writer<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span>data<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">);</span>
      <span class="sh_cbracket">}</span> <span class="sh_keyword">else</span> <span class="sh_cbracket">{</span>
        <span class="sh_comment">// 检查是否可以继续写入。 </span>
        <span class="sh_comment">// 这里不要传递 callback， 因为写入还没有结束！ </span>
        ok <span class="sh_symbol">=</span> writer<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span>data<span class="sh_symbol">,</span> encoding<span class="sh_symbol">);</span>
      <span class="sh_cbracket">}</span>
    <span class="sh_cbracket">}</span> <span class="sh_keyword">while</span> <span class="sh_symbol">(</span>i <span class="sh_symbol">&gt;</span> <span class="sh_number">0</span> <span class="sh_symbol">&amp;&amp;</span> ok<span class="sh_symbol">);</span>
    <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>i <span class="sh_symbol">&gt;</span> <span class="sh_number">0</span><span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
      <span class="sh_comment">// 这里提前停下了， </span>
      <span class="sh_comment">// 'drain' 事件触发后才可以继续写入  </span>
      writer<span class="sh_symbol">.</span><span class="sh_function">once</span><span class="sh_symbol">(</span><span class="sh_string">'drain'</span><span class="sh_symbol">,</span> write<span class="sh_symbol">);</span>
    <span class="sh_cbracket">}</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<h5>'error' 事件<span><a class="mark" href="stream.html#stream_event_error" id="stream_event_error">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_error">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_error.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a></li>
</ul>
<p><code>'error'</code> 事件在写入数据出错或者使用管道出错时触发。事件发生时，回掉函数仅会接收到一个 <code>Error</code> 参数。</p>
<p><em>注意</em>: <code>'error'</code> 事件发生时，流并不会关闭。</p>
<h5>'finish' 事件<span><a class="mark" href="stream.html#stream_event_finish" id="stream_event_finish">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_finish">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_finish.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><p>在调用了 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 方法，且缓冲区数据都已经传给底层系统（underlying system）之后， <code>'finish'</code> 事件将被触发。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> writer <span class="sh_symbol">=</span> <span class="sh_function">getWritableStreamSomehow</span><span class="sh_symbol">();</span>
<span class="sh_keyword">for</span> <span class="sh_symbol">(</span><span class="sh_keyword">var</span> i <span class="sh_symbol">=</span> <span class="sh_number">0</span><span class="sh_symbol">;</span> i <span class="sh_symbol">&lt;</span> <span class="sh_number">100</span><span class="sh_symbol">;</span> i <span class="sh_symbol">++)</span> <span class="sh_cbracket">{</span>
  writer<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'hello, #${i}!</span><span class="sh_specialchar">\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span>
writer<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span><span class="sh_string">'This is the end</span><span class="sh_specialchar">\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
writer<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'finish'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">error</span><span class="sh_symbol">(</span><span class="sh_string">'All writes are now complete.'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h5>'pipe' 事件<span><a class="mark" href="stream.html#stream_event_pipe" id="stream_event_pipe">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_pipe">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_pipe.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>src</code> <a href="stream.html#stream_class_stream_readable" class="type">&lt;stream.Readable&gt;</a> 输出到目标可写流（writable）的源流（source stream）</li>
</ul>
<p>在可读流（readable stream）上调用 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> 方法，并在目标流向 (destinations) 中添加当前可写流 ( writable ) 时，将会在可写流上触发 <code>'pipe'</code> 事件。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> writer <span class="sh_symbol">=</span> <span class="sh_function">getWritableStreamSomehow</span><span class="sh_symbol">();</span>
<span class="sh_keyword">const</span> reader <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
writer<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'pipe'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>src<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">error</span><span class="sh_symbol">(</span><span class="sh_string">'something is piping into the writer'</span><span class="sh_symbol">);</span>
  assert<span class="sh_symbol">.</span><span class="sh_function">equal</span><span class="sh_symbol">(</span>src<span class="sh_symbol">,</span> reader<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
reader<span class="sh_symbol">.</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>writer<span class="sh_symbol">);</span>
</code></pre>
<h5>'unpipe' 事件<span><a class="mark" href="stream.html#stream_event_unpipe" id="stream_event_unpipe">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_unpipe">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_unpipe.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>src</code> <span class="type">&lt;<a href="stream.html#stream_class_stream_readable">Readable</a> Stream&gt;</span> <a href="stream.html#stream_readable_unpipe_destination">unpiped</a> 当前可写流的源流</li>
</ul>
<p>在 <a href="stream.html#stream_class_stream_readable">Readable</a> 上调用 <a href="stream.html#stream_readable_unpipe_destination"><code>stream.unpipe()</code></a> 方法，从目标流向中移除当前 <a href="stream.html#stream_class_stream_writable">Writable</a> 时，将会触发 <code>'unpipe'</code> 事件。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> writer <span class="sh_symbol">=</span> <span class="sh_function">getWritableStreamSomehow</span><span class="sh_symbol">();</span>
<span class="sh_keyword">const</span> reader <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
writer<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'unpipe'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>src<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">error</span><span class="sh_symbol">(</span><span class="sh_string">'Something has stopped piping into the writer.'</span><span class="sh_symbol">);</span>
  assert<span class="sh_symbol">.</span><span class="sh_function">equal</span><span class="sh_symbol">(</span>src<span class="sh_symbol">,</span> reader<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
reader<span class="sh_symbol">.</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>writer<span class="sh_symbol">);</span>
reader<span class="sh_symbol">.</span><span class="sh_function">unpipe</span><span class="sh_symbol">(</span>writer<span class="sh_symbol">);</span>
</code></pre>
<h5>writable.cork()<span><a class="mark" href="stream.html#stream_writable_cork" id="stream_writable_cork">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_cork">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_cork.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.11.2</span>
</div><p>调用 <code>writable.cork()</code> 方法将强制所有写入数据都内存中的缓冲区里。
直到调用 <a href="stream.html#stream_writable_uncork"><code>stream.uncork()</code></a> 或
<a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 方法时，缓冲区里的数据才会被输出。</p>
<p>在向流中写入大量小块数据（small chunks of data）时，内部缓冲区（internal
buffer）可能失效，从而导致性能下降。<code>writable.cork()</code> 方法主要就是用来避免这种情况。 对于这种情况，
实现了 <code>writable._writev()</code> 方法的流可以对写入的数据进行缓冲，从而提高写入效率。</p>
<p>也可查看 <a href="stream.html#stream_writable_uncork"><code>writable.uncork()</code></a>。</p>
<h5>writable.end([chunk][, encoding][, callback])<span><a class="mark" href="stream.html#stream_writable_end_chunk_encoding_callback" id="stream_writable_end_chunk_encoding_callback">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_end_chunk_encoding_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_end_chunk_encoding_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <span class="type">&lt;any&gt;</span> 可选的，需要写入的数据。对于非对象模式下的流， <code>chunk</code> 必须是字符串或者 <code>Buffer</code>。对于对象模式下的流， <code>chunk</code> 可以是任意的 JavaScript 值，除了 <code>null</code>。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> 如果 <code>chunk</code> 是字符串，这里指定字符编码。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> 可选的，流结束时的回调函数。</li>
</ul>
<p>调用 <code>writable.end()</code> 方法表明接下来没有数据要被写入 <a href="stream.html#stream_class_stream_writable">Writable</a>。通过传入可选的 <code>chunk</code> 和 <code>encoding</code> 参数，可以在关闭流之前再写入一段数据。如果传入了可选的 <code>callback</code> 函数，它将作为 <a href="stream.html#stream_event_finish"><code>'finish'</code></a> 事件的回调函数。</p>
<p>在调用了 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 方法之后，再调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 方法将会导致错误。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_comment">// 写入 'hello, ' ，并用 'world!' 来结束写入</span>
<span class="sh_keyword">const</span> file <span class="sh_symbol">=</span> fs<span class="sh_symbol">.</span><span class="sh_function">createWriteStream</span><span class="sh_symbol">(</span><span class="sh_string">'example.txt'</span><span class="sh_symbol">);</span>
file<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'hello, '</span><span class="sh_symbol">);</span>
file<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span><span class="sh_string">'world!'</span><span class="sh_symbol">);</span>
<span class="sh_comment">// 后面不允许再写入数据！</span>
</code></pre>
<h5>writable.setDefaultEncoding(encoding)<span><a class="mark" href="stream.html#stream_writable_setdefaultencoding_encoding" id="stream_writable_setdefaultencoding_encoding">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_setdefaultencoding_encoding">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_setdefaultencoding_encoding.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> 新的默认编码</li>
<li>返回： <code>this</code></li>
</ul>
<p><code>writable.setDefaultEncoding()</code> 用于为 <a href="stream.html#stream_class_stream_writable">Writable</a> 设置 <code>encoding</code>。</p>
<h5>writable.uncork()<span><a class="mark" href="stream.html#stream_writable_uncork" id="stream_writable_uncork">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_uncork">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_uncork.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.11.2</span>
</div><p><code>writable.uncork()</code> 将输出在 <a href="stream.html#stream_writable_cork"><code>stream.cork()</code></a> 方法被调用之后缓冲在内存中的所有数据。</p>
<p>如果使用 <a href="stream.html#stream_writable_cork"><code>writable.cork()</code></a> 和 <code>writable.uncork()</code> 来管理写入缓存，建议使用 <code>process.nextTick()</code> 来延迟调用 <code>writable.uncork()</code> 方法。通过这种方式，可以对单个 Node.js 事件循环中调用的所有 <code>writable.write()</code> 方法进行批处理。</p>
<pre class="sh_sourceCode"><code class="lang-js">stream<span class="sh_symbol">.</span><span class="sh_function">cork</span><span class="sh_symbol">();</span>
stream<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'some '</span><span class="sh_symbol">);</span>
stream<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'data '</span><span class="sh_symbol">);</span>
process<span class="sh_symbol">.</span><span class="sh_function">nextTick</span><span class="sh_symbol">(()</span> <span class="sh_symbol">=&gt;</span> stream<span class="sh_symbol">.</span><span class="sh_function">uncork</span><span class="sh_symbol">());</span>
</code></pre>
<p>如果一个流多次调用了 <a href="stream.html#stream_writable_cork"><code>writable.cork()</code></a> 方法，那么也必须调用同样次数的 <code>writable.uncork()</code> 方法以输出缓冲区数据。</p>
<pre class="sh_sourceCode"><code class="lang-js">stream<span class="sh_symbol">.</span><span class="sh_function">cork</span><span class="sh_symbol">();</span>
stream<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'some '</span><span class="sh_symbol">);</span>
stream<span class="sh_symbol">.</span><span class="sh_function">cork</span><span class="sh_symbol">();</span>
stream<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'data '</span><span class="sh_symbol">);</span>
process<span class="sh_symbol">.</span><span class="sh_function">nextTick</span><span class="sh_symbol">(()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  stream<span class="sh_symbol">.</span><span class="sh_function">uncork</span><span class="sh_symbol">();</span>
  <span class="sh_comment">// 之前的数据只有在 uncork() 被二次调用后才会输出</span>
  stream<span class="sh_symbol">.</span><span class="sh_function">uncork</span><span class="sh_symbol">();</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>也可查看 <a href="stream.html#stream_writable_cork"><code>writable.cork()</code></a>。</p>
<h5>writable.write(chunk[, encoding][, callback])<span><a class="mark" href="stream.html#stream_writable_write_chunk_encoding_callback" id="stream_writable_write_chunk_encoding_callback">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_write_chunk_encoding_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_write_chunk_encoding_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> 要写入的数据</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> 如果 <code>chunk</code> 是字符串，这里指定字符编码</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> 缓冲数据输出时的回调函数</li>
<li>返回： <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> 如果流需要等待 <code>'drain'</code> 事件触发才能继续写入数据，这里将返回 <code>false</code> ； 否则返回 <code>true</code>。</li>
</ul>
<p><code>writable.write()</code> 方法向流中写入数据，并在数据处理完成后调用 <code>callback</code> 。如果有错误发生， <code>callback</code> <em>不一定</em> 会接收到这个错误作为第一个参数。要确保可靠地检测到写入错误，应该监听
<code>'error'</code> 事件。</p>
<p>在确认了 <code>chunk</code> 后，如果内部缓冲区的大小小于创建流时设定的 <code>highWaterMark</code> 阈值，函数将返回 <code>true</code> 。
如果返回值为 <code>false</code> ，应该停止向流中写入数据，直到 <a href="stream.html#stream_event_drain"><code>'drain'</code></a> 事件被触发。</p>
<p>While a stream is not draining, calls to <code>write()</code> will buffer <code>chunk</code>, and
return false. Once all currently buffered chunks are drained (accepted for
delivery by the operating system), the <code>'drain'</code> event will be emitted.
It is recommended that once write() returns false, no more chunks be written
until the <code>'drain'</code> event is emitted. While calling <code>write()</code> on a stream that
is not draining is allowed, Node.js will buffer all written chunks until
maximum memory usage occurs, at which point it will abort unconditionally.
Even before it aborts, high memory usage will cause poor garbage collector
performance and high RSS (which is not typically released back to the system,
even after the memory is no longer required). Since TCP sockets may never
drain if the remote peer does not read the data, writing a socket that is
not draining may lead to a remotely exploitable vulnerability.</p>
<p>Writing data while the stream is not draining is particularly
problematic for a <a href="stream.html#stream_class_stream_transform">Transform</a>, because the <code>Transform</code> streams are paused
by default until they are piped or an <code>'data'</code> or <code>'readable'</code> event handler
is added.</p>
<p>If the data to be written can be generated or fetched on demand, it is
recommended to encapsulate the logic into a <a href="stream.html#stream_class_stream_readable">Readable</a> and use
<a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a>. However, if calling <code>write()</code> is preferred, it is
possible to respect backpressure and avoid memory issues using the
the <a href="stream.html#stream_event_drain"><code>'drain'</code></a> event:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">function</span> <span class="sh_function">write</span> <span class="sh_symbol">(</span>data<span class="sh_symbol">,</span> cb<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(!</span>stream<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span>data<span class="sh_symbol">))</span> <span class="sh_cbracket">{</span>
    stream<span class="sh_symbol">.</span><span class="sh_function">once</span><span class="sh_symbol">(</span><span class="sh_string">'drain'</span><span class="sh_symbol">,</span> cb<span class="sh_symbol">)</span>
  <span class="sh_cbracket">}</span> <span class="sh_keyword">else</span> <span class="sh_cbracket">{</span>
    process<span class="sh_symbol">.</span><span class="sh_function">nextTick</span><span class="sh_symbol">(</span>cb<span class="sh_symbol">)</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>

<span class="sh_comment">// Wait for cb to be called before doing any other write.</span>
<span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'hello'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'write completed, do more writes now'</span><span class="sh_symbol">)</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">)</span>
</code></pre>
<p>对象模式的写入流将忽略 <code>encoding</code> 参数。</p>
<h3>可读流<span><a class="mark" href="stream.html#stream_readable_streams" id="stream_readable_streams">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_streams">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_streams.md">参与翻译</a></p>
<p>可读流（Readable streams）是对提供数据的 <em>源头</em> （source）的抽象。</p>
<p>可读流的例子包括：</p>
<ul>
<li><a href="http.html#http_class_http_incomingmessage">HTTP responses, on the client</a></li>
<li><a href="http.html#http_class_http_incomingmessage">HTTP requests, on the server</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs read streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="child_process.html#child_process_child_stdout">child process stdout and stderr</a></li>
<li><a href="process.html#process_process_stdin"><code>process.stdin</code></a></li>
</ul>
<p>所有的 <a href="stream.html#stream_class_stream_readable">Readable</a> 都实现了
<code>stream.Readable</code> 类定义的接口。</p>
<h4>两种模式<span><a class="mark" href="stream.html#stream_two_modes" id="stream_two_modes">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_two_modes">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/two_modes.md">参与翻译</a></p>
<p>可读流事实上工作在下面两种模式之一：flowing 和 paused 。</p>
<p>在 flowing 模式下， 可读流自动从系统底层读取数据，并通过 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> 接口的事件尽快将数据提供给应用。</p>
<p>在 paused 模式下，必须显式调用 <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 方法来从流中读取数据片段。</p>
<p>所有初始工作模式为 paused 的 <a href="stream.html#stream_class_stream_readable">Readable</a> 流，可以通过下面三种途径切换到 flowing
模式：</p>
<ul>
<li>监听 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件。</li>
<li>调用 <a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> 方法。</li>
<li>调用 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> 方法将数据发送到 <a href="stream.html#stream_class_stream_writable">Writable</a>。</li>
</ul>
<p>可读流可以通过下面途径切换到 paused 模式：</p>
<ul>
<li>如果不存在管道目标（pipe destination），可以通过调用
<a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> 方法实现。</li>
<li>如果存在管道目标，可以通过取消 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件监听，并调用 <a href="stream.html#stream_readable_unpipe_destination"><code>stream.unpipe()</code></a> 方法移除所有管道目标来实现。</li>
</ul>
<p>这里需要记住的重要概念就是，可读流需要先为其提供消费或忽略数据的机制，才能开始提供数据。如果消费机制被禁用或取消，可读流将 <em>尝试</em>
停止生成数据。</p>
<p><em>注意</em>: 为了向后兼容，取消 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件监听并 <strong>不会</strong> 自动将流暂停。同时，如果存在管道目标（pipe destination），且目标状态变为可以接收数据（drain and ask for
more data），调用了 <a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> 方法也并不保证流会一直 <em>保持</em> 暂停状态。</p>
<p><em>注意</em>: 如果 <a href="stream.html#stream_class_stream_readable">Readable</a> 切换到 flowing 模式，且没有消费者处理流中的数据，这些数据将会丢失。
比如， 调用了 <code>readable.resume()</code> 方法却没有监听 <code>'data'</code> 事件，或是取消了 <code>'data'</code> 事件监听，就有可能出现这种情况。</p>
<h4>三种状态<span><a class="mark" href="stream.html#stream_three_states" id="stream_three_states">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_three_states">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/three_states.md">参与翻译</a></p>
<p>可读流的“两种操作模式”是一种简单抽象。它抽象了在可读流实现（Readable stream implementation）内部发生的复杂的状态管理过程。</p>
<p>在任意时刻，任意可读流应确切处于下面三种状态之一：</p>
<ul>
<li><code>readable._readableState.flowing = null</code></li>
<li><code>readable._readableState.flowing = false</code></li>
<li><code>readable._readableState.flowing = true</code></li>
</ul>
<p>若 <code>readable._readableState.flowing</code> 为 <code>null</code>，由于不存在数据消费者，可读流将不会产生数据。</p>
<p>如果监听 <code>'data'</code> 事件，调用 <code>readable.pipe()</code>
方法，或者调用 <code>readable.resume()</code> 方法，
<code>readable._readableState.flowing</code> 的值将会变为 <code>true</code> 。这时，随着数据生成，可读流开始频繁触发事件。</p>
<p>调用 <code>readable.pause()</code> 方法， <code>readable.unpipe()</code> 方法， 或者接收 “背压”（back pressure），
将导致 <code>readable._readableState.flowing</code> 值变为 <code>false</code>。
这将暂停事件流，但 <em>不会</em> 暂停数据生成。</p>
<p>当 <code>readable._readableState.flowing</code> 值为 <code>false</code> 时， 数据可能堆积到流的内部缓存中。</p>
<h4>选择一种<span><a class="mark" href="stream.html#stream_choose_one" id="stream_choose_one">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_choose_one">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/choose_one.md">参与翻译</a></p>
<p>可读流 API 的演化贯穿了多个 Node.js 版本，提供了多种方法来消费流数据。通常开发者应该选择其中 <em>一种</em> 来消费数据，而 <em>不应该</em> 在单个流使用多种方法来消费数据。</p>
<p>对于大多数用户，建议使用 <code>readable.pipe()</code> 方法来消费流数据，因为它是最简单的一种实现。开发者如果要精细地控制数据传递和产生的过程，可以使用 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> 和 <code>readable.pause()</code>/<code>readable.resume()</code> 提供的 API 。</p>
<h4>stream.Readable 类<span><a class="mark" href="stream.html#stream_class_stream_readable" id="stream_class_stream_readable">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_class_stream_readable">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/class_stream_readable.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><!--type=class-->
<h5>'close' 事件<span><a class="mark" href="stream.html#stream_event_close_1" id="stream_event_close_1">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_close_1">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_close_1.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><p><code>'close'</code> 事件将在流或其底层资源（比如一个文件）关闭后触发。<code>'close'</code> 事件触发后，该流将不会再触发任何事件。</p>
<p>不是所有 <a href="stream.html#stream_class_stream_readable">Readable</a> 都会触发 <code>'close'</code> 事件。</p>
<h5>'data' 事件<span><a class="mark" href="stream.html#stream_event_data" id="stream_event_data">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_data">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_data.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <span class="type">&lt;any&gt;</span> 数据片段。对于非对象模式的可读流，这是一个字符串或者 <code>Buffer</code>。
对于对象模式的可读流，这可以是除 <code>null</code> 以外的任意类型 JavaScript 值。</li>
</ul>
<p><code>'data'</code> 事件会在流将数据传递给消费者时触发。当流转换到 flowing 模式时会触发该事件。调用 <code>readable.pipe()</code>， <code>readable.resume()</code> 方法，或为 <code>'data'</code> 事件添加回调可以将流转换到 flowing 模式。 <code>'data'</code> 事件也会在调用 <code>readable.read()</code> 方法并有数据返回时触发。</p>
<p>在没有明确暂停的流上添加 <code>'data'</code> 事件监听会将流转换为 flowing 模式。 数据会在可用时尽快传递给下个流程。</p>
<p>如果调用 <code>readable.setEncoding()</code> 方法明确为流指定了默认编码，回调函数将接收到一个字符串，否则接收到的数据将是一个
<code>Buffer</code> 实例。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
readable<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>`Received $<span class="sh_cbracket">{</span>chunk<span class="sh_symbol">.</span>length<span class="sh_cbracket">}</span> bytes of data<span class="sh_symbol">.</span>`<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h5>'end' 事件<span><a class="mark" href="stream.html#stream_event_end" id="stream_event_end">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_end">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_end.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><p><code>'end'</code> 事件将在流中再没有数据可供消费时触发。</p>
<p><em>注意</em>： <code>'end'</code> 事件只有在数据被完全消费后 <strong>才会触发</strong> 。 可以在数据被完全消费后，通过将流转换到 
flowing 模式， 或反复调用 <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 方法来实现这一点。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
readable<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>`Received $<span class="sh_cbracket">{</span>chunk<span class="sh_symbol">.</span>length<span class="sh_cbracket">}</span> bytes of data<span class="sh_symbol">.</span>`<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
readable<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'There will be no more data.'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h5>'error' 事件<span><a class="mark" href="stream.html#stream_event_error_1" id="stream_event_error_1">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_error_1">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_error_1.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a></li>
</ul>
<p><code>'error'</code> 事件可以在任何时候在可读流实现（Readable implementation）上触发。
通常，这会在底层系统内部出错从而不能产生数据，或当流的实现试图传递错误数据时发生。</p>
<p>回调函数将接收到一个 <code>Error</code> 对象。</p>
<h5>'readable' 事件<span><a class="mark" href="stream.html#stream_event_readable" id="stream_event_readable">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_event_readable">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/event_readable.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><p><code>'readable'</code> 事件将在流中有数据可供读取时触发。在某些情况下，为 <code>'readable'</code> 事件添加回调将会导致一些数据被读取到内部缓存中。</p>
<pre class="sh_sourceCode"><code class="lang-javascript"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
readable<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'readable'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_comment">// 有一些数据可读了</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>当到达流数据尾部时， <code>'readable'</code> 事件也会触发。触发顺序在 <code>'end'</code> 事件之前。</p>
<p>事实上， <code>'readable'</code> 事件表明流有了新的动态：要么是有了新的数据，要么是到了流的尾部。 对于前者， <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 将返回可用的数据。而对于后者， <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 将返回
<code>null</code>。 例如，下面的例子中的 <code>foo.txt</code> 是一个空文件：</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> fs <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'fs'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">const</span> rr <span class="sh_symbol">=</span> fs<span class="sh_symbol">.</span><span class="sh_function">createReadStream</span><span class="sh_symbol">(</span><span class="sh_string">'foo.txt'</span><span class="sh_symbol">);</span>
rr<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'readable'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'readable:'</span><span class="sh_symbol">,</span> rr<span class="sh_symbol">.</span><span class="sh_function">read</span><span class="sh_symbol">());</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
rr<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>上面交脚本的输出如下：</p>
<pre class="sh_sourceCode"><code class="lang-txt">$ node test<span class="sh_symbol">.</span>js
readable<span class="sh_symbol">:</span> <span class="sh_keyword">null</span>
end
</code></pre>
<p><em>注意</em>： 通常情况下， 应该使用 <code>readable.pipe()</code> 方法和 <code>'data'</code> 事件机制，而不是 <code>'readable'</code> 事件。</p>
<h5>readable.isPaused()<span><a class="mark" href="stream.html#stream_readable_ispaused" id="stream_readable_ispaused">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_ispaused">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_ispaused.md">参与翻译</a></p>
<!--
added: v0.11.14
-->
<ul>
<li>返回： <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a></li>
</ul>
<p><code>readable.isPaused()</code> 方法返回可读流的当前操作状态。 该方法主要是在
<code>readable.pipe()</code> 方法的底层机制中用到。大多数情况下，没有必要直接使用该方法。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> stream<span class="sh_symbol">.</span>Readable

readable<span class="sh_symbol">.</span><span class="sh_function">isPaused</span><span class="sh_symbol">()</span> <span class="sh_comment">// === false</span>
readable<span class="sh_symbol">.</span><span class="sh_function">pause</span><span class="sh_symbol">()</span>
readable<span class="sh_symbol">.</span><span class="sh_function">isPaused</span><span class="sh_symbol">()</span> <span class="sh_comment">// === true</span>
readable<span class="sh_symbol">.</span><span class="sh_function">resume</span><span class="sh_symbol">()</span>
readable<span class="sh_symbol">.</span><span class="sh_function">isPaused</span><span class="sh_symbol">()</span> <span class="sh_comment">// === false</span>
</code></pre>
<h5>readable.pause()<span><a class="mark" href="stream.html#stream_readable_pause" id="stream_readable_pause">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_pause">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_pause.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li>返回： <code>this</code></li>
</ul>
<p><code>readable.pause()</code> 方法将会使 flowing 模式的流停止触发 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件， 进而切出 flowing 模式。任何可用的数据都将保存在内部缓存中。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
readable<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>`Received $<span class="sh_cbracket">{</span>chunk<span class="sh_symbol">.</span>length<span class="sh_cbracket">}</span> bytes of data<span class="sh_symbol">.</span>`<span class="sh_symbol">);</span>
  readable<span class="sh_symbol">.</span><span class="sh_function">pause</span><span class="sh_symbol">();</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'There will be no additional data for 1 second.'</span><span class="sh_symbol">);</span>
  <span class="sh_function">setTimeout</span><span class="sh_symbol">(()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
    console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'Now data will start flowing again.'</span><span class="sh_symbol">);</span>
    readable<span class="sh_symbol">.</span><span class="sh_function">resume</span><span class="sh_symbol">();</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">,</span> <span class="sh_number">1000</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h5>readable.pipe(destination[, options])<span><a class="mark" href="stream.html#stream_readable_pipe_destination_options" id="stream_readable_pipe_destination_options">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_pipe_destination_options">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_pipe_destination_options.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>destination</code> <a href="stream.html#stream_class_stream_writable" class="type">&lt;stream.Writable&gt;</a> 数据写入目标</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> Pipe 选项<ul>
<li><code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> 在 reader 结束时结束 writer 。默认为 <code>true</code>。</li>
</ul>
</li>
</ul>
<p><code>readable.pipe()</code> 绑定一个 <a href="stream.html#stream_class_stream_writable">Writable</a> 到 <code>readable</code> 上，
将可写流自动切换到 flowing 模式并将所有数据传给绑定的 <a href="stream.html#stream_class_stream_writable">Writable</a>。数据流将被自动管理。这样，即使是可读流较快，目标可写流也不会超负荷（overwhelmed）。</p>
<p>下面例子将 <code>readable</code> 中的所有数据通过管道传递给名为 <code>file.txt</code> 的文件：</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
<span class="sh_keyword">const</span> writable <span class="sh_symbol">=</span> fs<span class="sh_symbol">.</span><span class="sh_function">createWriteStream</span><span class="sh_symbol">(</span><span class="sh_string">'file.txt'</span><span class="sh_symbol">);</span>
<span class="sh_comment">// readable 中的所有数据都传给了 'file.txt'</span>
readable<span class="sh_symbol">.</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>writable<span class="sh_symbol">);</span>
</code></pre>
<p>可以在单个可读流上绑定多个可写流。</p>
<p><code>readable.pipe()</code> 方法返回 <em>目标流</em> 的引用，这样就可以对流进行链式地管道操作：</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> r <span class="sh_symbol">=</span> fs<span class="sh_symbol">.</span><span class="sh_function">createReadStream</span><span class="sh_symbol">(</span><span class="sh_string">'file.txt'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">const</span> z <span class="sh_symbol">=</span> zlib<span class="sh_symbol">.</span><span class="sh_function">createGzip</span><span class="sh_symbol">();</span>
<span class="sh_keyword">const</span> w <span class="sh_symbol">=</span> fs<span class="sh_symbol">.</span><span class="sh_function">createWriteStream</span><span class="sh_symbol">(</span><span class="sh_string">'file.txt.gz'</span><span class="sh_symbol">);</span>
r<span class="sh_symbol">.</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>z<span class="sh_symbol">).</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>w<span class="sh_symbol">);</span>
</code></pre>
<p>默认情况下，当源可读流（the source Readable stream）触发 <a href="stream.html#stream_event_end"><code>'end'</code></a> 事件时，目标流也会调用 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 方法从而结束写入。要禁用这一默认行为， <code>end</code>
选项应该指定为 <code>false</code>， 这将使目标流保持打开，
如下面例子所示：</p>
<pre class="sh_sourceCode"><code class="lang-js">reader<span class="sh_symbol">.</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>writer<span class="sh_symbol">,</span> <span class="sh_cbracket">{</span> end<span class="sh_symbol">:</span> <span class="sh_keyword">false</span> <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
reader<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  writer<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span><span class="sh_string">'Goodbye</span><span class="sh_specialchar">\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>这里有一点要警惕，如果可读流在处理时发生错误，目标可写流 <em>不会</em> 自动关闭。
如果发生错误，需要 <em>手动</em> 关闭所有流以避免内存泄漏。</p>
<p><em>注意</em>：不管对 <a href="process.html#process_process_stderr"><code>process.stderr</code></a> 和 <a href="process.html#process_process_stdout"><code>process.stdout</code></a> 指定什么选项，它们都是直到 Node.js 进程退出才关闭。</p>
<h5>readable.read([size])<span><a class="mark" href="stream.html#stream_readable_read_size" id="stream_readable_read_size">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_read_size">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_read_size.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Optional argument to specify how much data to read.</li>
<li>Return <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;Null&gt;</a></li>
</ul>
<p>The <code>readable.read()</code> method pulls some data out of the internal buffer and
returns it. If no data available to be read, <code>null</code> is returned. By default,
the data will be returned as a <code>Buffer</code> object unless an encoding has been
specified using the <code>readable.setEncoding()</code> method or the stream is operating
in object mode.</p>
<p>The optional <code>size</code> argument specifies a specific number of bytes to read. If
<code>size</code> bytes are not available to be read, <code>null</code> will be returned <em>unless</em>
the stream has ended, in which case all of the data remaining in the internal
buffer will be returned (<em>even if it exceeds <code>size</code> bytes</em>).</p>
<p>If the <code>size</code> argument is not specified, all of the data contained in the
internal buffer will be returned.</p>
<p>The <code>readable.read()</code> method should only be called on Readable streams operating
in paused mode. In flowing mode, <code>readable.read()</code> is called automatically until
the internal buffer is fully drained.</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
readable<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'readable'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">var</span> chunk<span class="sh_symbol">;</span>
  <span class="sh_keyword">while</span> <span class="sh_symbol">(</span><span class="sh_keyword">null</span> <span class="sh_symbol">!==</span> <span class="sh_symbol">(</span>chunk <span class="sh_symbol">=</span> readable<span class="sh_symbol">.</span><span class="sh_function">read</span><span class="sh_symbol">()))</span> <span class="sh_cbracket">{</span>
    console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>`Received $<span class="sh_cbracket">{</span>chunk<span class="sh_symbol">.</span>length<span class="sh_cbracket">}</span> bytes of data<span class="sh_symbol">.</span>`<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>In general, it is recommended that developers avoid the use of the <code>'readable'</code>
event and the <code>readable.read()</code> method in favor of using either
<code>readable.pipe()</code> or the <code>'data'</code> event.</p>
<p>A Readable stream in object mode will always return a single item from
a call to <a href="stream.html#stream_readable_read_size"><code>readable.read(size)</code></a>, regardless of the value of the
<code>size</code> argument.</p>
<p><em>Note:</em> If the <code>readable.read()</code> method returns a chunk of data, a <code>'data'</code>
event will also be emitted.</p>
<p><em>Note</em>: Calling <a href="stream.html#stream_readable_read_size"><code>stream.read([size])</code></a> after the <a href="stream.html#stream_event_end"><code>'end'</code></a>
event has been emitted will return <code>null</code>. No runtime error will be raised.</p>
<h5>readable.resume()<span><a class="mark" href="stream.html#stream_readable_resume" id="stream_readable_resume">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_resume">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_resume.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li>Returns: <code>this</code></li>
</ul>
<p>The <code>readable.resume()</code> method causes an explicitly paused Readable stream to
resume emitting <a href="stream.html#stream_event_data"><code>'data'</code></a> events, switching the stream into flowing mode.</p>
<p>The <code>readable.resume()</code> method can be used to fully consume the data from a
stream without actually processing any of that data as illustrated in the
following example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">()</span>
  <span class="sh_symbol">.</span><span class="sh_function">resume</span><span class="sh_symbol">()</span>
  <span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
    console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'Reached the end, but did not read anything.'</span><span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h5>readable.setEncoding(encoding)<span><a class="mark" href="stream.html#stream_readable_setencoding_encoding" id="stream_readable_setencoding_encoding">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_setencoding_encoding">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_setencoding_encoding.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> 要使用的编码</li>
<li>Returns: <code>this</code></li>
</ul>
<p><code>readble.setEncoding()</code> 方法会为从可读流读入的数据设置默认字符编码</p>
<p>设置编码会使得该流数据返回指定编码的字符串而不是<code>Buffer</code>对象。例如，调用<code>readable.setEncoding('utf-8')</code>会使得输出数据作为UTF-8数据解析，并作为字符串返回。调用<code>readable.setEncoding('hex')</code>使得数据被编码成16进制字符串格式。</p>
<p>可读流会妥善处理多字节字符，如果仅仅直接从流中取出<code>Buffer</code>对象，很可能会导致错误解码。</p>
<p>调用<code>readable.setEncoding(null)</code>可以禁止编码。该方法在处理二进制数据或大字节字符串分割为许多块时非常有用。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
readable<span class="sh_symbol">.</span><span class="sh_function">setEncoding</span><span class="sh_symbol">(</span><span class="sh_string">'utf8'</span><span class="sh_symbol">);</span>
readable<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  assert<span class="sh_symbol">.</span><span class="sh_function">equal</span><span class="sh_symbol">(</span><span class="sh_keyword">typeof</span> chunk<span class="sh_symbol">,</span> <span class="sh_string">'string'</span><span class="sh_symbol">);</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'got %d characters of string data'</span><span class="sh_symbol">,</span> chunk<span class="sh_symbol">.</span>length<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h5>readable.unpipe([destination])<span><a class="mark" href="stream.html#stream_readable_unpipe_destination" id="stream_readable_unpipe_destination">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_unpipe_destination">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_unpipe_destination.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>destination</code> <a href="stream.html#stream_class_stream_writable" class="type">&lt;stream.Writable&gt;</a> Optional specific stream to unpipe</li>
</ul>
<p>The <code>readable.unpipe()</code> method detaches a Writable stream previously attached
using the <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> method.</p>
<p>If the <code>destination</code> is not specified, then <em>all</em> pipes are detached.</p>
<p>If the <code>destination</code> is specified, but no pipe is set up for it, then
the method does nothing.</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> readable <span class="sh_symbol">=</span> <span class="sh_function">getReadableStreamSomehow</span><span class="sh_symbol">();</span>
<span class="sh_keyword">const</span> writable <span class="sh_symbol">=</span> fs<span class="sh_symbol">.</span><span class="sh_function">createWriteStream</span><span class="sh_symbol">(</span><span class="sh_string">'file.txt'</span><span class="sh_symbol">);</span>
<span class="sh_comment">// All the data from readable goes into 'file.txt',</span>
<span class="sh_comment">// but only for the first second</span>
readable<span class="sh_symbol">.</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>writable<span class="sh_symbol">);</span>
<span class="sh_function">setTimeout</span><span class="sh_symbol">(()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'Stop writing to file.txt'</span><span class="sh_symbol">);</span>
  readable<span class="sh_symbol">.</span><span class="sh_function">unpipe</span><span class="sh_symbol">(</span>writable<span class="sh_symbol">);</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'Manually close the file stream'</span><span class="sh_symbol">);</span>
  writable<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">();</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">,</span> <span class="sh_number">1000</span><span class="sh_symbol">);</span>
</code></pre>
<h5>readable.unshift(chunk)<span><a class="mark" href="stream.html#stream_readable_unshift_chunk" id="stream_readable_unshift_chunk">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_unshift_chunk">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_unshift_chunk.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.11</span>
</div><ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> Chunk of data to unshift onto the read queue</li>
</ul>
<p>The <code>readable.unshift()</code> method pushes a chunk of data back into the internal
buffer. This is useful in certain situations where a stream is being consumed by
code that needs to "un-consume" some amount of data that it has optimistically
pulled out of the source, so that the data can be passed on to some other party.</p>
<p><em>Note</em>: The <code>stream.unshift(chunk)</code> method cannot be called after the
<a href="stream.html#stream_event_end"><code>'end'</code></a> event has been emitted or a runtime error will be thrown.</p>
<p>Developers using <code>stream.unshift()</code> often should consider switching to
use of a <a href="stream.html#stream_class_stream_transform">Transform</a> stream instead. See the <a href="stream.html#stream_api_for_stream_implementers">API for Stream Implementers</a>
section for more information.</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_comment">// Pull off a header delimited by \n\n</span>
<span class="sh_comment">// use unshift() if we get too much</span>
<span class="sh_comment">// Call the callback with (error, header, stream)</span>
<span class="sh_keyword">const</span> StringDecoder <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'string_decoder'</span><span class="sh_symbol">).</span>StringDecoder<span class="sh_symbol">;</span>
<span class="sh_keyword">function</span> <span class="sh_function">parseHeader</span><span class="sh_symbol">(</span>stream<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  stream<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'error'</span><span class="sh_symbol">,</span> callback<span class="sh_symbol">);</span>
  stream<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'readable'</span><span class="sh_symbol">,</span> onReadable<span class="sh_symbol">);</span>
  <span class="sh_keyword">const</span> decoder <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">StringDecoder</span><span class="sh_symbol">(</span><span class="sh_string">'utf8'</span><span class="sh_symbol">);</span>
  <span class="sh_keyword">var</span> header <span class="sh_symbol">=</span> <span class="sh_string">''</span><span class="sh_symbol">;</span>
  <span class="sh_keyword">function</span> <span class="sh_function">onReadable</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">var</span> chunk<span class="sh_symbol">;</span>
    <span class="sh_keyword">while</span> <span class="sh_symbol">(</span><span class="sh_keyword">null</span> <span class="sh_symbol">!==</span> <span class="sh_symbol">(</span>chunk <span class="sh_symbol">=</span> stream<span class="sh_symbol">.</span><span class="sh_function">read</span><span class="sh_symbol">()))</span> <span class="sh_cbracket">{</span>
      <span class="sh_keyword">var</span> str <span class="sh_symbol">=</span> decoder<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">);</span>
      <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>str<span class="sh_symbol">.</span><span class="sh_function">match</span><span class="sh_symbol">(</span><span class="sh_regexp">/\n\n/</span><span class="sh_symbol">))</span> <span class="sh_cbracket">{</span>
        <span class="sh_comment">// found the header boundary</span>
        <span class="sh_keyword">var</span> split <span class="sh_symbol">=</span> str<span class="sh_symbol">.</span><span class="sh_function">split</span><span class="sh_symbol">(</span><span class="sh_regexp">/\n\n/</span><span class="sh_symbol">);</span>
        header <span class="sh_symbol">+=</span> split<span class="sh_symbol">.</span><span class="sh_function">shift</span><span class="sh_symbol">();</span>
        <span class="sh_keyword">const</span> remaining <span class="sh_symbol">=</span> split<span class="sh_symbol">.</span><span class="sh_function">join</span><span class="sh_symbol">(</span><span class="sh_string">'</span><span class="sh_specialchar">\n\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
        <span class="sh_keyword">const</span> buf <span class="sh_symbol">=</span> Buffer<span class="sh_symbol">.</span><span class="sh_function">from</span><span class="sh_symbol">(</span>remaining<span class="sh_symbol">,</span> <span class="sh_string">'utf8'</span><span class="sh_symbol">);</span>
        stream<span class="sh_symbol">.</span><span class="sh_function">removeListener</span><span class="sh_symbol">(</span><span class="sh_string">'error'</span><span class="sh_symbol">,</span> callback<span class="sh_symbol">);</span>
        <span class="sh_comment">// set the readable listener before unshifting</span>
        stream<span class="sh_symbol">.</span><span class="sh_function">removeListener</span><span class="sh_symbol">(</span><span class="sh_string">'readable'</span><span class="sh_symbol">,</span> onReadable<span class="sh_symbol">);</span>
        <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>buf<span class="sh_symbol">.</span>length<span class="sh_symbol">)</span>
          stream<span class="sh_symbol">.</span><span class="sh_function">unshift</span><span class="sh_symbol">(</span>buf<span class="sh_symbol">);</span>
        <span class="sh_comment">// now the body of the message can be read from the stream.</span>
        <span class="sh_function">callback</span><span class="sh_symbol">(</span><span class="sh_keyword">null</span><span class="sh_symbol">,</span> header<span class="sh_symbol">,</span> stream<span class="sh_symbol">);</span>
      <span class="sh_cbracket">}</span> <span class="sh_keyword">else</span> <span class="sh_cbracket">{</span>
        <span class="sh_comment">// still reading the header.</span>
        header <span class="sh_symbol">+=</span> str<span class="sh_symbol">;</span>
      <span class="sh_cbracket">}</span>
    <span class="sh_cbracket">}</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p><em>Note</em>: Unlike <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>, <code>stream.unshift(chunk)</code>
will not end the reading process by resetting the internal reading state of the
stream. This can cause unexpected results if <code>readable.unshift()</code> is called
during a read (i.e. from within a <a href="stream.html#stream_readable_read_size_1"><code>stream._read()</code></a>
implementation on a custom stream). Following the call to <code>readable.unshift()</code>
with an immediate <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push('')</code></a> will reset the reading state
appropriately, however it is best to simply avoid calling <code>readable.unshift()</code>
while in the process of performing a read.</p>
<h5>readable.wrap(stream)<span><a class="mark" href="stream.html#stream_readable_wrap_stream" id="stream_readable_wrap_stream">#</a></span></h5><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_wrap_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_wrap_stream.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><ul>
<li><code>stream</code> <a href="stream.html#stream_stream" class="type">&lt;Stream&gt;</a> An "old style" readable stream</li>
</ul>
<p>Versions of Node.js prior to v0.10 had streams that did not implement the
entire <code>stream</code> module API as it is currently defined. (See <a href="stream.html#stream_compatibility_with_older_node_js_versions">Compatibility</a>
for more information.)</p>
<p>When using an older Node.js library that emits <a href="stream.html#stream_event_data"><code>'data'</code></a> events and has a
<a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> method that is advisory only, the
<code>readable.wrap()</code> method can be used to create a <a href="stream.html#stream_class_stream_readable">Readable</a> stream that uses
the old stream as its data source.</p>
<p>It will rarely be necessary to use <code>readable.wrap()</code> but the method has been
provided as a convenience for interacting with older Node.js applications and
libraries.</p>
<p>For example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> OldReader <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'./old-api-module.js'</span><span class="sh_symbol">).</span>OldReader<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> Readable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Readable<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> oreader <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> OldReader<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> myReader <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Readable</span><span class="sh_symbol">().</span><span class="sh_function">wrap</span><span class="sh_symbol">(</span>oreader<span class="sh_symbol">);</span>

myReader<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'readable'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  myReader<span class="sh_symbol">.</span><span class="sh_function">read</span><span class="sh_symbol">();</span> <span class="sh_comment">// etc.</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h3>Duplex 流与 Transform 流<span><a class="mark" href="stream.html#stream_duplex_and_transform_streams" id="stream_duplex_and_transform_streams">#</a></span></h3>
<h4>stream.Duplex 类<span><a class="mark" href="stream.html#stream_class_stream_duplex" id="stream_class_stream_duplex">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_class_stream_duplex">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/class_stream_duplex.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><!--type=class-->
<p>Duplex 流是同时实现了 <a href="stream.html#stream_class_stream_readable">Readable</a> 和
<a href="stream.html#stream_class_stream_writable">Writable</a> 接口的流。</p>
<p>Duplex 流的实例包括了：</p>
<ul>
<li><a href="net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
</ul>
<h4>stream.Transform 类<span><a class="mark" href="stream.html#stream_class_stream_transform" id="stream_class_stream_transform">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_class_stream_transform">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/class_stream_transform.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div><!--type=class-->
<p>变换流（Transform streams） 是一种 <a href="stream.html#stream_class_stream_duplex">Duplex</a> 流。它的输出与输入是通过某种方式关联的。和所有 <a href="stream.html#stream_class_stream_duplex">Duplex</a> 流一样，变换流同时实现了 <a href="stream.html#stream_class_stream_readable">Readable</a> 和 <a href="stream.html#stream_class_stream_writable">Writable</a> 接口。</p>
<p>变换流的实例包括：</p>
<ul>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
</ul>
<h2>API for Stream Implementers<span><a class="mark" href="stream.html#stream_api_for_stream_implementers" id="stream_api_for_stream_implementers">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_api_for_stream_implementers">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/api_for_stream_implementers.md">参与翻译</a></p>
<!--type=misc-->
<p>The <code>stream</code> module API has been designed to make it possible to easily
implement streams using JavaScript's prototypal inheritance model.</p>
<p>First, a stream developer would declare a new JavaScript class that extends one
of the four basic stream classes (<code>stream.Writable</code>, <code>stream.Readable</code>,
<code>stream.Duplex</code>, or <code>stream.Transform</code>), making sure the call the appropriate
parent class constructor:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Writable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Writable<span class="sh_symbol">;</span>

<span class="sh_keyword">class</span> MyWritable <span class="sh_keyword">extends</span> Writable <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p>The new stream class must then implement one or more specific methods, depending
on the type of stream being created, as detailed in the chart below:</p>
<table>
  <thead>
    <tr>
      <th>
        <p>Use-case</p>
      </th>
      <th>
        <p>Class</p>
      </th>
      <th>
        <p>Method(s) to implement</p>
      </th>
    </tr>
  </thead>
  <tbody><tr>
    <td>
      <p>Reading only</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_readable">Readable</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_readable_read_size_1">_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Writing only</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_writable">Writable</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code>, <code><a href="stream.html#stream_writable_writev_chunks_callback">_writev</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Reading and writing</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_duplex">Duplex</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_readable_read_size_1">_read</a></code>, <code><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code>, <code><a href="stream.html#stream_writable_writev_chunks_callback">_writev</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Operate on written data, then read the result</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_transform">Transform</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_transform_transform_chunk_encoding_callback">_transform</a></code>, <code><a href="stream.html#stream_transform_flush_callback">_flush</a></code></p>
    </td>
  </tr>
</tbody></table>

<p><em>Note</em>: The implementation code for a stream should <em>never</em> call the "public"
methods of a stream that are intended for use by consumers (as described in
the <a href="stream.html#stream_api_for_stream_consumers">API for Stream Consumers</a> section). Doing so may lead to adverse
side effects in application code consuming the stream.</p>
<h3>Simplified Construction<span><a class="mark" href="stream.html#stream_simplified_construction" id="stream_simplified_construction">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_simplified_construction">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/simplified_construction.md">参与翻译</a></p>
<p>For many simple cases, it is possible to construct a stream without relying on
inheritance. This can be accomplished by directly creating instances of the
<code>stream.Writable</code>, <code>stream.Readable</code>, <code>stream.Duplex</code> or <code>stream.Transform</code>
objects and passing appropriate methods as constructor options.</p>
<p>For example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Writable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Writable<span class="sh_symbol">;</span>

<span class="sh_keyword">const</span> myWritable <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Writable</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  <span class="sh_function">write</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// ...</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h3>Implementing a Writable Stream<span><a class="mark" href="stream.html#stream_implementing_a_writable_stream" id="stream_implementing_a_writable_stream">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_implementing_a_writable_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/implementing_a_writable_stream.md">参与翻译</a></p>
<p>The <code>stream.Writable</code> class is extended to implement a <a href="stream.html#stream_class_stream_writable">Writable</a> stream.</p>
<p>Custom Writable streams <em>must</em> call the <code>new stream.Writable([options])</code>
constructor and implement the <code>writable._write()</code> method. The
<code>writable._writev()</code> method <em>may</em> also be implemented.</p>
<h4>Constructor: new stream.Writable([options])<span><a class="mark" href="stream.html#stream_constructor_new_stream_writable_options" id="stream_constructor_new_stream_writable_options">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_constructor_new_stream_writable_options">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/constructor_new_stream_writable_options.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a><ul>
<li><code>highWaterMark</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Buffer level when
<a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> starts returning <code>false</code>. Defaults to
<code>16384</code> (16kb), or <code>16</code> for <code>objectMode</code> streams.</li>
<li><code>decodeStrings</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Whether or not to decode strings into
Buffers before passing them to <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>stream._write()</code></a>.
Defaults to <code>true</code></li>
<li><code>objectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Whether or not the
<a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(anyObj)</code></a> is a valid operation. When set,
it becomes possible to write JavaScript values other than string or
<code>Buffer</code> if supported by the stream implementation. Defaults to <code>false</code></li>
<li><code>write</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Implementation for the
<a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>stream._write()</code></a> method.</li>
<li><code>writev</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Implementation for the
<a href="stream.html#stream_writable_writev_chunks_callback"><code>stream._writev()</code></a> method.</li>
</ul>
</li>
</ul>
</div><p>For example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Writable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Writable<span class="sh_symbol">;</span>

<span class="sh_keyword">class</span> MyWritable <span class="sh_keyword">extends</span> Writable <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// Calls the stream.Writable() constructor</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p>Or, when using pre-ES6 style constructors:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Writable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Writable<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> util <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'util'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">function</span> <span class="sh_function">MyWritable</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(!(</span><span class="sh_keyword">this</span> <span class="sh_keyword">instanceof</span> MyWritable<span class="sh_symbol">))</span>
    <span class="sh_keyword">return</span> <span class="sh_keyword">new</span> <span class="sh_function">MyWritable</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  Writable<span class="sh_symbol">.</span><span class="sh_function">call</span><span class="sh_symbol">(</span><span class="sh_keyword">this</span><span class="sh_symbol">,</span> options<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span>
util<span class="sh_symbol">.</span><span class="sh_function">inherits</span><span class="sh_symbol">(</span>MyWritable<span class="sh_symbol">,</span> Writable<span class="sh_symbol">);</span>
</code></pre>
<p>Or, using the Simplified Constructor approach:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Writable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Writable<span class="sh_symbol">;</span>

<span class="sh_keyword">const</span> myWritable <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Writable</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  <span class="sh_function">write</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// ...</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">,</span>
  <span class="sh_function">writev</span><span class="sh_symbol">(</span>chunks<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// ...</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h4>writable._write(chunk, encoding, callback)<span><a class="mark" href="stream.html#stream_writable_write_chunk_encoding_callback_1" id="stream_writable_write_chunk_encoding_callback_1">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_write_chunk_encoding_callback_1">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_write_chunk_encoding_callback_1.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> The chunk to be written. Will <strong>always</strong>
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If the chunk is a string, then <code>encoding</code> is the
character encoding of that string. If chunk is a <code>Buffer</code>, or if the
stream is operating in object mode, <code>encoding</code> may be ignored.</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Call this function (optionally with an error
argument) when processing is complete for the supplied chunk.</li>
</ul>
</div><p>All Writable stream implementations must provide a
<a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a> method to send data to the underlying
resource.</p>
<p><em>Note</em>: <a href="stream.html#stream_class_stream_transform">Transform</a> streams provide their own implementation of the
<a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a>.</p>
<p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It
should be implemented by child classes, and called only by the internal Writable
class methods only.</p>
<p>The <code>callback</code> method must be called to signal either that the write completed
successfully or failed with an error. The first argument passed to the
<code>callback</code> must be the <code>Error</code> object if the call failed or <code>null</code> if the
write succeeded.</p>
<p>It is important to note that all calls to <code>writable.write()</code> that occur between
the time <code>writable._write()</code> is called and the <code>callback</code> is called will cause
the written data to be buffered. Once the <code>callback</code> is invoked, the stream will
emit a <a href="stream.html#stream_event_drain"><code>'drain'</code></a> event. If a stream implementation is capable of processing
multiple chunks of data at once, the <code>writable._writev()</code> method should be
implemented.</p>
<p>If the <code>decodeStrings</code> property is set in the constructor options, then
<code>chunk</code> may be a string rather than a Buffer, and <code>encoding</code> will
indicate the character encoding of the string. This is to support
implementations that have an optimized handling for certain string
data encodings. If the <code>decodeStrings</code> property is explicitly set to <code>false</code>,
the <code>encoding</code> argument can be safely ignored, and <code>chunk</code> will remain the same
object that is passed to <code>.write()</code>.</p>
<p>The <code>writable._write()</code> method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.</p>
<h4>writable._writev(chunks, callback)<span><a class="mark" href="stream.html#stream_writable_writev_chunks_callback" id="stream_writable_writev_chunks_callback">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_writable_writev_chunks_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/writable_writev_chunks_callback.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>chunks</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type">&lt;Array&gt;</a> The chunks to be written. Each chunk has following
format: <code>{ chunk: ..., encoding: ... }</code>.</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> A callback function (optionally with an error
argument) to be invoked when processing is complete for the supplied chunks.</li>
</ul>
</div><p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It
should be implemented by child classes, and called only by the internal Writable
class methods only.</p>
<p>The <code>writable._writev()</code> method may be implemented in addition to
<code>writable._write()</code> in stream implementations that are capable of processing
multiple chunks of data at once. If implemented, the method will be called with
all chunks of data currently buffered in the write queue.</p>
<p>The <code>writable._writev()</code> method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.</p>
<h4>Errors While Writing<span><a class="mark" href="stream.html#stream_errors_while_writing" id="stream_errors_while_writing">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_errors_while_writing">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/errors_while_writing.md">参与翻译</a></p>
<p>It is recommended that errors occurring during the processing of the
<code>writable._write()</code> and <code>writable._writev()</code> methods are reported by invoking
the callback and passing the error as the first argument. This will cause an
<code>'error'</code> event to be emitted by the Writable. Throwing an Error from within
<code>writable._write()</code> can result in unexpected and inconsistent behavior depending
on how the stream is being used.  Using the callback ensures consistent and
predictable handling of errors.</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Writable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Writable<span class="sh_symbol">;</span>

<span class="sh_keyword">const</span> myWritable <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Writable</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  <span class="sh_function">write</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">.</span><span class="sh_function">toString</span><span class="sh_symbol">().</span><span class="sh_function">indexOf</span><span class="sh_symbol">(</span><span class="sh_string">'a'</span><span class="sh_symbol">)</span> <span class="sh_symbol">&gt;=</span> <span class="sh_number">0</span><span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
      <span class="sh_function">callback</span><span class="sh_symbol">(</span><span class="sh_keyword">new</span> <span class="sh_predef_func">Error</span><span class="sh_symbol">(</span><span class="sh_string">'chunk is invalid'</span><span class="sh_symbol">));</span>
    <span class="sh_cbracket">}</span> <span class="sh_keyword">else</span> <span class="sh_cbracket">{</span>
      <span class="sh_function">callback</span><span class="sh_symbol">();</span>
    <span class="sh_cbracket">}</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h4>一个可写流的例子<span><a class="mark" href="stream.html#stream_an_example_writable_stream" id="stream_an_example_writable_stream">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_an_example_writable_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/an_example_writable_stream.md">参与翻译</a></p>
<p>下面说明了一个相当简单（有点无意义）的可写流实现。虽然这个具体的可写流实例没有任何真正的特殊用途，但该示例说明了一个自定义流实例所需要的元素：</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Writable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Writable<span class="sh_symbol">;</span>

<span class="sh_keyword">class</span> MyWritable <span class="sh_keyword">extends</span> Writable <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>

  <span class="sh_function">_write</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">.</span><span class="sh_function">toString</span><span class="sh_symbol">().</span><span class="sh_function">indexOf</span><span class="sh_symbol">(</span><span class="sh_string">'a'</span><span class="sh_symbol">)</span> <span class="sh_symbol">&gt;=</span> <span class="sh_number">0</span><span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
      <span class="sh_function">callback</span><span class="sh_symbol">(</span><span class="sh_keyword">new</span> <span class="sh_predef_func">Error</span><span class="sh_symbol">(</span><span class="sh_string">'chunk is invalid'</span><span class="sh_symbol">));</span>
    <span class="sh_cbracket">}</span> <span class="sh_keyword">else</span> <span class="sh_cbracket">{</span>
      <span class="sh_function">callback</span><span class="sh_symbol">();</span>
    <span class="sh_cbracket">}</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<h3>Implementing a Readable Stream<span><a class="mark" href="stream.html#stream_implementing_a_readable_stream" id="stream_implementing_a_readable_stream">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_implementing_a_readable_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/implementing_a_readable_stream.md">参与翻译</a></p>
<p>The <code>stream.Readable</code> class is extended to implement a <a href="stream.html#stream_class_stream_readable">Readable</a> stream.</p>
<p>Custom Readable streams <em>must</em> call the <code>new stream.Readable([options])</code>
constructor and implement the <code>readable._read()</code> method.</p>
<h4>new stream.Readable([options])<span><a class="mark" href="stream.html#stream_new_stream_readable_options" id="stream_new_stream_readable_options">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_new_stream_readable_options">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/new_stream_readable_options.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a><ul>
<li><code>highWaterMark</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> The maximum number of bytes to store in
the internal buffer before ceasing to read from the underlying
resource. Defaults to <code>16384</code> (16kb), or <code>16</code> for <code>objectMode</code> streams</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If specified, then buffers will be decoded to
strings using the specified encoding. Defaults to <code>null</code></li>
<li><code>objectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Whether this stream should behave
as a stream of objects. Meaning that <a href="stream.html#stream_readable_read_size"><code>stream.read(n)</code></a> returns
a single value instead of a Buffer of size n. Defaults to <code>false</code></li>
<li><code>read</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Implementation for the <a href="stream.html#stream_readable_read_size_1"><code>stream._read()</code></a>
method.</li>
</ul>
</li>
</ul>
</div><p>For example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Readable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Readable<span class="sh_symbol">;</span>

<span class="sh_keyword">class</span> MyReadable <span class="sh_keyword">extends</span> Readable <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// Calls the stream.Readable(options) constructor</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p>Or, when using pre-ES6 style constructors:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Readable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Readable<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> util <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'util'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">function</span> <span class="sh_function">MyReadable</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(!(</span><span class="sh_keyword">this</span> <span class="sh_keyword">instanceof</span> MyReadable<span class="sh_symbol">))</span>
    <span class="sh_keyword">return</span> <span class="sh_keyword">new</span> <span class="sh_function">MyReadable</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  Readable<span class="sh_symbol">.</span><span class="sh_function">call</span><span class="sh_symbol">(</span><span class="sh_keyword">this</span><span class="sh_symbol">,</span> options<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span>
util<span class="sh_symbol">.</span><span class="sh_function">inherits</span><span class="sh_symbol">(</span>MyReadable<span class="sh_symbol">,</span> Readable<span class="sh_symbol">);</span>
</code></pre>
<p>Or, using the Simplified Constructor approach:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Readable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Readable<span class="sh_symbol">;</span>

<span class="sh_keyword">const</span> myReadable <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Readable</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  <span class="sh_function">read</span><span class="sh_symbol">(</span>size<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// ...</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h4>readable._read(size)<span><a class="mark" href="stream.html#stream_readable_read_size_1" id="stream_readable_read_size_1">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_read_size_1">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_read_size_1.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Number of bytes to read asynchronously</li>
</ul>
</div><p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It
should be implemented by child classes, and called only by the internal Readable
class methods only.</p>
<p>All Readable stream implementations must provide an implementation of the
<code>readable._read()</code> method to fetch data from the underlying resource.</p>
<p>When <code>readable._read()</code> is called, if data is available from the resource, the
implementation should begin pushing that data into the read queue using the
<a href="stream.html#stream_readable_push_chunk_encoding"><code>this.push(dataChunk)</code></a> method. <code>_read()</code> should continue reading
from the resource and pushing data until <code>readable.push()</code> returns <code>false</code>. Only
when <code>_read()</code> is called again after it has stopped should it resume pushing
additional data onto the queue.</p>
<p><em>Note</em>: Once the <code>readable._read()</code> method has been called, it will not be
called again until the <a href="stream.html#stream_readable_push_chunk_encoding"><code>readable.push()</code></a> method is called.</p>
<p>The <code>size</code> argument is advisory. For implementations where a "read" is a
single operation that returns data can use the <code>size</code> argument to determine how
much data to fetch. Other implementations may ignore this argument and simply
provide data whenever it becomes available. There is no need to "wait" until
<code>size</code> bytes are available before calling <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.</p>
<p>The <code>readable._read()</code> method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.</p>
<h4>readable.push(chunk[, encoding])<span><a class="mark" href="stream.html#stream_readable_push_chunk_encoding" id="stream_readable_push_chunk_encoding">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_push_chunk_encoding">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_push_chunk_encoding.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;Null&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> Chunk of data to push into the read queue</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> Encoding of String chunks.  Must be a valid
Buffer encoding, such as <code>'utf8'</code> or <code>'ascii'</code></li>
<li>Returns <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> <code>true</code> if additional chunks of data may continued to be
pushed; <code>false</code> otherwise.</li>
</ul>
</div><p>When <code>chunk</code> is a <code>Buffer</code> or <code>string</code>, the <code>chunk</code> of data will be added to the
internal queue for users of the stream to consume. Passing <code>chunk</code> as <code>null</code>
signals the end of the stream (EOF), after which no more data can be written.</p>
<p>When the Readable is operating in paused mode, the data added with
<code>readable.push()</code> can be read out by calling the
<a href="stream.html#stream_readable_read_size"><code>readable.read()</code></a> method when the <a href="stream.html#stream_event_readable"><code>'readable'</code></a> event is
emitted.</p>
<p>When the Readable is operating in flowing mode, the data added with
<code>readable.push()</code> will be delivered by emitting a <code>'data'</code> event.</p>
<p>The <code>readable.push()</code> method is designed to be as flexible as possible. For
example, when wrapping a lower-level source that provides some form of
pause/resume mechanism, and a data callback, the low-level source can be wrapped
by the custom Readable instance as illustrated in the following example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_comment">// source is an object with readStop() and readStart() methods,</span>
<span class="sh_comment">// and an `ondata` member that gets called when it has data, and</span>
<span class="sh_comment">// an `onend` member that gets called when the data is over.</span>

<span class="sh_keyword">class</span> SourceWrapper <span class="sh_keyword">extends</span> Readable <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>

    <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_source <span class="sh_symbol">=</span> <span class="sh_function">getLowlevelSourceObject</span><span class="sh_symbol">();</span>

    <span class="sh_comment">// Every time there's data, push it into the internal buffer.</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_source<span class="sh_symbol">.</span>ondata <span class="sh_symbol">=</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
      <span class="sh_comment">// if push() returns false, then stop reading from source</span>
      <span class="sh_keyword">if</span> <span class="sh_symbol">(!</span><span class="sh_keyword">this</span><span class="sh_symbol">.</span><span class="sh_function">push</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">))</span>
        <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_source<span class="sh_symbol">.</span><span class="sh_function">readStop</span><span class="sh_symbol">();</span>
    <span class="sh_cbracket">}</span><span class="sh_symbol">;</span>

    <span class="sh_comment">// When the source ends, push the EOF-signaling `null` chunk</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_source<span class="sh_symbol">.</span>onend <span class="sh_symbol">=</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
      <span class="sh_keyword">this</span><span class="sh_symbol">.</span><span class="sh_function">push</span><span class="sh_symbol">(</span><span class="sh_keyword">null</span><span class="sh_symbol">);</span>
    <span class="sh_cbracket">}</span><span class="sh_symbol">;</span>
  <span class="sh_cbracket">}</span>
  <span class="sh_comment">// _read will be called when the stream wants to pull more data in</span>
  <span class="sh_comment">// the advisory size argument is ignored in this case.</span>
  <span class="sh_function">_read</span><span class="sh_symbol">(</span>size<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_source<span class="sh_symbol">.</span><span class="sh_function">readStart</span><span class="sh_symbol">();</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p><em>Note</em>: The <code>readable.push()</code> method is intended be called only by Readable
Implementers, and only from within the <code>readable._read()</code> method.</p>
<h4>Errors While Reading<span><a class="mark" href="stream.html#stream_errors_while_reading" id="stream_errors_while_reading">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_errors_while_reading">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/errors_while_reading.md">参与翻译</a></p>
<p>It is recommended that errors occurring during the processing of the
<code>readable._read()</code> method are emitted using the <code>'error'</code> event rather than
being thrown. Throwing an Error from within <code>readable._read()</code> can result in
unexpected and inconsistent behavior depending on whether the stream is
operating in flowing or paused mode. Using the <code>'error'</code> event ensures
consistent and predictable handling of errors.</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Readable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Readable<span class="sh_symbol">;</span>

<span class="sh_keyword">const</span> myReadable <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Readable</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  <span class="sh_function">read</span><span class="sh_symbol">(</span>size<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">if</span> <span class="sh_symbol">(</span><span class="sh_function">checkSomeErrorCondition</span><span class="sh_symbol">())</span> <span class="sh_cbracket">{</span>
      process<span class="sh_symbol">.</span><span class="sh_function">nextTick</span><span class="sh_symbol">(()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_keyword">this</span><span class="sh_symbol">.</span><span class="sh_function">emit</span><span class="sh_symbol">(</span><span class="sh_string">'error'</span><span class="sh_symbol">,</span> err<span class="sh_symbol">));</span>
      <span class="sh_keyword">return</span><span class="sh_symbol">;</span>
    <span class="sh_cbracket">}</span>
    <span class="sh_comment">// do some work</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h4>一个数流的例子<span><a class="mark" href="stream.html#stream_an_example_counting_stream" id="stream_an_example_counting_stream">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_an_example_counting_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/an_example_counting_stream.md">参与翻译</a></p>
<!--type=example-->
<p>以下是可读流的一个基本例子，触发数字1到1,000,000升序，然后结束</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Readable <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Readable<span class="sh_symbol">;</span>

<span class="sh_keyword">class</span> Counter <span class="sh_keyword">extends</span> Readable <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>opt<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>opt<span class="sh_symbol">);</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_max <span class="sh_symbol">=</span> <span class="sh_number">1000000</span><span class="sh_symbol">;</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_index <span class="sh_symbol">=</span> <span class="sh_number">1</span><span class="sh_symbol">;</span>
  <span class="sh_cbracket">}</span>

  <span class="sh_function">_read</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">var</span> i <span class="sh_symbol">=</span> <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_index<span class="sh_symbol">++;</span>
    <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>i <span class="sh_symbol">&gt;</span> <span class="sh_keyword">this</span><span class="sh_symbol">.</span>_max<span class="sh_symbol">)</span>
      <span class="sh_keyword">this</span><span class="sh_symbol">.</span><span class="sh_function">push</span><span class="sh_symbol">(</span><span class="sh_keyword">null</span><span class="sh_symbol">);</span>
    <span class="sh_keyword">else</span> <span class="sh_cbracket">{</span>
      <span class="sh_keyword">var</span> str <span class="sh_symbol">=</span> <span class="sh_string">''</span> <span class="sh_symbol">+</span> i<span class="sh_symbol">;</span>
      <span class="sh_keyword">var</span> buf <span class="sh_symbol">=</span> Buffer<span class="sh_symbol">.</span><span class="sh_function">from</span><span class="sh_symbol">(</span>str<span class="sh_symbol">,</span> <span class="sh_string">'ascii'</span><span class="sh_symbol">);</span>
      <span class="sh_keyword">this</span><span class="sh_symbol">.</span><span class="sh_function">push</span><span class="sh_symbol">(</span>buf<span class="sh_symbol">);</span>
    <span class="sh_cbracket">}</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<h3>Implementing a Duplex Stream<span><a class="mark" href="stream.html#stream_implementing_a_duplex_stream" id="stream_implementing_a_duplex_stream">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_implementing_a_duplex_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/implementing_a_duplex_stream.md">参与翻译</a></p>
<p>A <a href="stream.html#stream_class_stream_duplex">Duplex</a> stream is one that implements both <a href="stream.html#stream_class_stream_readable">Readable</a> and <a href="stream.html#stream_class_stream_writable">Writable</a>,
such as a TCP socket connection.</p>
<p>Because JavaScript does not have support for multiple inheritance, the
<code>stream.Duplex</code> class is extended to implement a <a href="stream.html#stream_class_stream_duplex">Duplex</a> stream (as opposed
to extending the <code>stream.Readable</code> <em>and</em> <code>stream.Writable</code> classes).</p>
<p><em>Note</em>: The <code>stream.Duplex</code> class prototypically inherits from <code>stream.Readable</code>
and parasitically from <code>stream.Writable</code>, but <code>instanceof</code> will work properly
for both base classes due to overriding <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance"><code>Symbol.hasInstance</code></a>
on <code>stream.Writable</code>.</p>
<p>Custom Duplex streams <em>must</em> call the <code>new stream.Duplex([options])</code>
constructor and implement <em>both</em> the <code>readable._read()</code> and
<code>writable._write()</code> methods.</p>
<h4>new stream.Duplex(options)<span><a class="mark" href="stream.html#stream_new_stream_duplex_options" id="stream_new_stream_duplex_options">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_new_stream_duplex_options">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/new_stream_duplex_options.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> Passed to both Writable and Readable
constructors. Also has the following fields:<ul>
<li><code>allowHalfOpen</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Defaults to <code>true</code>. If set to <code>false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
<li><code>readableObjectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Defaults to <code>false</code>. Sets <code>objectMode</code>
for readable side of the stream. Has no effect if <code>objectMode</code>
is <code>true</code>.</li>
<li><code>writableObjectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Defaults to <code>false</code>. Sets <code>objectMode</code>
for writable side of the stream. Has no effect if <code>objectMode</code>
is <code>true</code>.</li>
</ul>
</li>
</ul>
</div><p>For example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Duplex <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Duplex<span class="sh_symbol">;</span>

<span class="sh_keyword">class</span> MyDuplex <span class="sh_keyword">extends</span> Duplex <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p>Or, when using pre-ES6 style constructors:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Duplex <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Duplex<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> util <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'util'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">function</span> <span class="sh_function">MyDuplex</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(!(</span><span class="sh_keyword">this</span> <span class="sh_keyword">instanceof</span> MyDuplex<span class="sh_symbol">))</span>
    <span class="sh_keyword">return</span> <span class="sh_keyword">new</span> <span class="sh_function">MyDuplex</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  Duplex<span class="sh_symbol">.</span><span class="sh_function">call</span><span class="sh_symbol">(</span><span class="sh_keyword">this</span><span class="sh_symbol">,</span> options<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span>
util<span class="sh_symbol">.</span><span class="sh_function">inherits</span><span class="sh_symbol">(</span>MyDuplex<span class="sh_symbol">,</span> Duplex<span class="sh_symbol">);</span>
</code></pre>
<p>Or, using the Simplified Constructor approach:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Duplex <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Duplex<span class="sh_symbol">;</span>

<span class="sh_keyword">const</span> myDuplex <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Duplex</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  <span class="sh_function">read</span><span class="sh_symbol">(</span>size<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// ...</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">,</span>
  <span class="sh_function">write</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// ...</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h4>An Example Duplex Stream<span><a class="mark" href="stream.html#stream_an_example_duplex_stream" id="stream_an_example_duplex_stream">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_an_example_duplex_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/an_example_duplex_stream.md">参与翻译</a></p>
<p>The following illustrates a simple example of a Duplex stream that wraps a
hypothetical lower-level source object to which data can be written, and
from which data can be read, albeit using an API that is not compatible with
Node.js streams.
The following illustrates a simple example of a Duplex stream that buffers
incoming written data via the <a href="stream.html#stream_class_stream_writable">Writable</a> interface that is read back out
via the <a href="stream.html#stream_class_stream_readable">Readable</a> interface.</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Duplex <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Duplex<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> kSource <span class="sh_symbol">=</span> <span class="sh_function">Symbol</span><span class="sh_symbol">(</span><span class="sh_string">'source'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">class</span> MyDuplex <span class="sh_keyword">extends</span> Duplex <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>source<span class="sh_symbol">,</span> options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">[</span>kSource<span class="sh_symbol">]</span> <span class="sh_symbol">=</span> source<span class="sh_symbol">;</span>
  <span class="sh_cbracket">}</span>

  <span class="sh_function">_write</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// The underlying source only deals with strings</span>
    <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>Buffer<span class="sh_symbol">.</span><span class="sh_function">isBuffer</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">))</span>
      chunk <span class="sh_symbol">=</span> chunk<span class="sh_symbol">.</span><span class="sh_function">toString</span><span class="sh_symbol">();</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">[</span>kSource<span class="sh_symbol">].</span><span class="sh_function">writeSomeData</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">);</span>
    <span class="sh_function">callback</span><span class="sh_symbol">();</span>
  <span class="sh_cbracket">}</span>

  <span class="sh_function">_read</span><span class="sh_symbol">(</span>size<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">this</span><span class="sh_symbol">[</span>kSource<span class="sh_symbol">].</span><span class="sh_function">fetchSomeData</span><span class="sh_symbol">(</span>size<span class="sh_symbol">,</span> <span class="sh_symbol">(</span>data<span class="sh_symbol">,</span> encoding<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
      <span class="sh_keyword">this</span><span class="sh_symbol">.</span><span class="sh_function">push</span><span class="sh_symbol">(</span>Buffer<span class="sh_symbol">.</span><span class="sh_function">from</span><span class="sh_symbol">(</span>data<span class="sh_symbol">,</span> encoding<span class="sh_symbol">));</span>
    <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p>The most important aspect of a Duplex stream is that the Readable and Writable
sides operate independently of one another despite co-existing within a single
object instance.</p>
<h4>Object Mode Duplex Streams<span><a class="mark" href="stream.html#stream_object_mode_duplex_streams" id="stream_object_mode_duplex_streams">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_object_mode_duplex_streams">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/object_mode_duplex_streams.md">参与翻译</a></p>
<p>For Duplex streams, <code>objectMode</code> can be set exclusively for either the Readable
or Writable side using the <code>readableObjectMode</code> and <code>writableObjectMode</code> options
respectively.</p>
<p>In the following example, for instance, a new Transform stream (which is a
type of <a href="stream.html#stream_class_stream_duplex">Duplex</a> stream) is created that has an object mode Writable side
that accepts JavaScript numbers that are converted to hexadecimal strings on
the Readable side.</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Transform <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Transform<span class="sh_symbol">;</span>

<span class="sh_comment">// All Transform streams are also Duplex Streams</span>
<span class="sh_keyword">const</span> myTransform <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Transform</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  writableObjectMode<span class="sh_symbol">:</span> <span class="sh_keyword">true</span><span class="sh_symbol">,</span>

  <span class="sh_function">transform</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// Coerce the chunk to a number if necessary</span>
    chunk <span class="sh_symbol">|=</span> <span class="sh_number">0</span><span class="sh_symbol">;</span>

    <span class="sh_comment">// Transform the chunk into something else.</span>
    <span class="sh_keyword">const</span> data <span class="sh_symbol">=</span> chunk<span class="sh_symbol">.</span><span class="sh_function">toString</span><span class="sh_symbol">(</span><span class="sh_number">16</span><span class="sh_symbol">);</span>

    <span class="sh_comment">// Push the data onto the readable queue.</span>
    <span class="sh_function">callback</span><span class="sh_symbol">(</span><span class="sh_keyword">null</span><span class="sh_symbol">,</span> <span class="sh_string">'0'</span><span class="sh_symbol">.</span><span class="sh_function">repeat</span><span class="sh_symbol">(</span>data<span class="sh_symbol">.</span>length <span class="sh_symbol">%</span> <span class="sh_number">2</span><span class="sh_symbol">)</span> <span class="sh_symbol">+</span> data<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

myTransform<span class="sh_symbol">.</span><span class="sh_function">setEncoding</span><span class="sh_symbol">(</span><span class="sh_string">'ascii'</span><span class="sh_symbol">);</span>
myTransform<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>chunk<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">));</span>

myTransform<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_number">1</span><span class="sh_symbol">);</span>
<span class="sh_comment">// Prints: 01</span>
myTransform<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_number">10</span><span class="sh_symbol">);</span>
<span class="sh_comment">// Prints: 0a</span>
myTransform<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_number">100</span><span class="sh_symbol">);</span>
<span class="sh_comment">// Prints: 64</span>
</code></pre>
<h3>Implementing a Transform Stream<span><a class="mark" href="stream.html#stream_implementing_a_transform_stream" id="stream_implementing_a_transform_stream">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_implementing_a_transform_stream">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/implementing_a_transform_stream.md">参与翻译</a></p>
<p>A <a href="stream.html#stream_class_stream_transform">Transform</a> stream is a <a href="stream.html#stream_class_stream_duplex">Duplex</a> stream where the output is computed
in some way from the input. Examples include <a href="zlib.html">zlib</a> streams or <a href="crypto.html">crypto</a>
streams that compress, encrypt, or decrypt data.</p>
<p><em>Note</em>: There is no requirement that the output be the same size as the input,
the same number of chunks, or arrive at the same time. For example, a
Hash stream will only ever have a single chunk of output which is
provided when the input is ended. A <code>zlib</code> stream will produce output
that is either much smaller or much larger than its input.</p>
<p>The <code>stream.Transform</code> class is extended to implement a <a href="stream.html#stream_class_stream_transform">Transform</a> stream.</p>
<p>The <code>stream.Transform</code> class prototypically inherits from <code>stream.Duplex</code> and
implements its own versions of the <code>writable._write()</code> and <code>readable._read()</code>
methods. Custom Transform implementations <em>must</em> implement the
<a href="stream.html#stream_transform_transform_chunk_encoding_callback"><code>transform._transform()</code></a> method and <em>may</em> also implement
the <a href="stream.html#stream_transform_flush_callback"><code>transform._flush()</code></a> method.</p>
<p><em>Note</em>: Care must be taken when using Transform streams in that data written
to the stream can cause the Writable side of the stream to become paused if
the output on the Readable side is not consumed.</p>
<h4>new stream.Transform([options])<span><a class="mark" href="stream.html#stream_new_stream_transform_options" id="stream_new_stream_transform_options">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_new_stream_transform_options">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/new_stream_transform_options.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> Passed to both Writable and Readable
constructors. Also has the following fields:<ul>
<li><code>transform</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Implementation for the
<a href="stream.html#stream_transform_transform_chunk_encoding_callback"><code>stream._transform()</code></a> method.</li>
<li><code>flush</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Implementation for the <a href="stream.html#stream_transform_flush_callback"><code>stream._flush()</code></a>
method.</li>
</ul>
</li>
</ul>
</div><p>For example:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Transform <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Transform<span class="sh_symbol">;</span>

<span class="sh_keyword">class</span> MyTransform <span class="sh_keyword">extends</span> Transform <span class="sh_cbracket">{</span>
  <span class="sh_function">constructor</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_keyword">super</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p>Or, when using pre-ES6 style constructors:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Transform <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Transform<span class="sh_symbol">;</span>
<span class="sh_keyword">const</span> util <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'util'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">function</span> <span class="sh_function">MyTransform</span><span class="sh_symbol">(</span>options<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(!(</span><span class="sh_keyword">this</span> <span class="sh_keyword">instanceof</span> MyTransform<span class="sh_symbol">))</span>
    <span class="sh_keyword">return</span> <span class="sh_keyword">new</span> <span class="sh_function">MyTransform</span><span class="sh_symbol">(</span>options<span class="sh_symbol">);</span>
  Transform<span class="sh_symbol">.</span><span class="sh_function">call</span><span class="sh_symbol">(</span><span class="sh_keyword">this</span><span class="sh_symbol">,</span> options<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span>
util<span class="sh_symbol">.</span><span class="sh_function">inherits</span><span class="sh_symbol">(</span>MyTransform<span class="sh_symbol">,</span> Transform<span class="sh_symbol">);</span>
</code></pre>
<p>Or, using the Simplified Constructor approach:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> Transform <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'stream'</span><span class="sh_symbol">).</span>Transform<span class="sh_symbol">;</span>

<span class="sh_keyword">const</span> myTransform <span class="sh_symbol">=</span> <span class="sh_keyword">new</span> <span class="sh_function">Transform</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  <span class="sh_function">transform</span><span class="sh_symbol">(</span>chunk<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// ...</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h4>Events: 'finish' and 'end'<span><a class="mark" href="stream.html#stream_events_finish_and_end" id="stream_events_finish_and_end">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_events_finish_and_end">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/events_finish_and_end.md">参与翻译</a></p>
<p>The <a href="stream.html#stream_event_finish"><code>'finish'</code></a> and <a href="stream.html#stream_event_end"><code>'end'</code></a> events are from the <code>stream.Writable</code>
and <code>stream.Readable</code> classes, respectively. The <code>'finish'</code> event is emitted
after <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> is called and all chunks have been processed
by <a href="stream.html#stream_transform_transform_chunk_encoding_callback"><code>stream._transform()</code></a>. The <code>'end'</code> event is emitted
after all data has been output, which occurs after the callback in
<a href="stream.html#stream_transform_flush_callback"><code>transform._flush()</code></a> has been called.</p>
<h4>transform._flush(callback)<span><a class="mark" href="stream.html#stream_transform_flush_callback" id="stream_transform_flush_callback">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_transform_flush_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/transform_flush_callback.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> A callback function (optionally with an error
argument) to be called when remaining data has been flushed.</li>
</ul>
</div><p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It
should be implemented by child classes, and called only by the internal Readable
class methods only.</p>
<p>In some cases, a transform operation may need to emit an additional bit of
data at the end of the stream. For example, a <code>zlib</code> compression stream will
store an amount of internal state used to optimally compress the output. When
the stream ends, however, that additional data needs to be flushed so that the
compressed data will be complete.</p>
<p>Custom <a href="stream.html#stream_class_stream_transform">Transform</a> implementations <em>may</em> implement the <code>transform._flush()</code>
method. This will be called when there is no more written data to be consumed,
but before the <a href="stream.html#stream_event_end"><code>'end'</code></a> event is emitted signaling the end of the
<a href="stream.html#stream_class_stream_readable">Readable</a> stream.</p>
<p>Within the <code>transform._flush()</code> implementation, the <code>readable.push()</code> method
may be called zero or more times, as appropriate. The <code>callback</code> function must
be called when the flush operation is complete.</p>
<p>The <code>transform._flush()</code> method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.</p>
<h4>transform._transform(chunk, encoding, callback)<span><a class="mark" href="stream.html#stream_transform_transform_chunk_encoding_callback" id="stream_transform_transform_chunk_encoding_callback">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_transform_transform_chunk_encoding_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/transform_transform_chunk_encoding_callback.md">参与翻译</a></p>
<div class="signature"><ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> The chunk to be transformed. Will <strong>always</strong>
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> If the chunk is a string, then this is the
encoding type. If chunk is a buffer, then this is the special
value - 'buffer', ignore it in this case.</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> A callback function (optionally with an error
argument and data) to be called after the supplied <code>chunk</code> has been
processed.</li>
</ul>
</div><p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It
should be implemented by child classes, and called only by the internal Readable
class methods only.</p>
<p>All Transform stream implementations must provide a <code>_transform()</code>
method to accept input and produce output. The <code>transform._transform()</code>
implementation handles the bytes being written, computes an output, then passes
that output off to the readable portion using the <code>readable.push()</code> method.</p>
<p>The <code>transform.push()</code> method may be called zero or more times to generate
output from a single input chunk, depending on how much is to be output
as a result of the chunk.</p>
<p>It is possible that no output is generated from any given chunk of input data.</p>
<p>The <code>callback</code> function must be called only when the current chunk is completely
consumed. The first argument passed to the <code>callback</code> must be an <code>Error</code> object
if an error occurred while processing the input or <code>null</code> otherwise. If a second
argument is passed to the <code>callback</code>, it will be forwarded on to the
<code>readable.push()</code> method. In other words the following are equivalent:</p>
<pre class="sh_sourceCode"><code class="lang-js">transform<span class="sh_symbol">.</span><span class="sh_keyword">prototype</span><span class="sh_symbol">.</span>_transform <span class="sh_symbol">=</span> <span class="sh_keyword">function</span> <span class="sh_symbol">(</span>data<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">this</span><span class="sh_symbol">.</span><span class="sh_function">push</span><span class="sh_symbol">(</span>data<span class="sh_symbol">);</span>
  <span class="sh_function">callback</span><span class="sh_symbol">();</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">;</span>

transform<span class="sh_symbol">.</span><span class="sh_keyword">prototype</span><span class="sh_symbol">.</span>_transform <span class="sh_symbol">=</span> <span class="sh_keyword">function</span> <span class="sh_symbol">(</span>data<span class="sh_symbol">,</span> encoding<span class="sh_symbol">,</span> callback<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_function">callback</span><span class="sh_symbol">(</span><span class="sh_keyword">null</span><span class="sh_symbol">,</span> data<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">;</span>
</code></pre>
<p>The <code>transform._transform()</code> method is prefixed with an underscore because it
is internal to the class that defines it, and should never be called directly by
user programs.</p>
<h4>Class: stream.PassThrough<span><a class="mark" href="stream.html#stream_class_stream_passthrough" id="stream_class_stream_passthrough">#</a></span></h4><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_class_stream_passthrough">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/class_stream_passthrough.md">参与翻译</a></p>
<p>The <code>stream.PassThrough</code> class is a trivial implementation of a <a href="stream.html#stream_class_stream_transform">Transform</a>
stream that simply passes the input bytes across to the output. Its purpose is
primarily for examples and testing, but there are some use cases where
<code>stream.PassThrough</code> is useful as a building block for novel sorts of streams.</p>
<h2>Additional Notes<span><a class="mark" href="stream.html#stream_additional_notes" id="stream_additional_notes">#</a></span></h2>
<!--type=misc-->
<h3>Compatibility with Older Node.js Versions<span><a class="mark" href="stream.html#stream_compatibility_with_older_node_js_versions" id="stream_compatibility_with_older_node_js_versions">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_compatibility_with_older_node_js_versions">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/compatibility_with_older_node_js_versions.md">参与翻译</a></p>
<!--type=misc-->
<p>In versions of Node.js prior to v0.10, the Readable stream interface was
simpler, but also less powerful and less useful.</p>
<ul>
<li>Rather than waiting for calls the <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> method,
<a href="stream.html#stream_event_data"><code>'data'</code></a> events would begin emitting immediately. Applications that
would need to perform some amount of work to decide how to handle data
were required to store read data into buffers so the data would not be lost.</li>
<li>The <a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> method was advisory, rather than
guaranteed. This meant that it was still necessary to be prepared to receive
<a href="stream.html#stream_event_data"><code>'data'</code></a> events <em>even when the stream was in a paused state</em>.</li>
</ul>
<p>In Node.js v0.10, the <a href="stream.html#stream_class_stream_readable">Readable</a> class was added. For backwards compatibility
with older Node.js programs, Readable streams switch into "flowing mode" when a
<a href="stream.html#stream_event_data"><code>'data'</code></a> event handler is added, or when the
<a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> method is called. The effect is that, even
when not using the new <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> method and
<a href="stream.html#stream_event_readable"><code>'readable'</code></a> event, it is no longer necessary to worry about losing
<a href="stream.html#stream_event_data"><code>'data'</code></a> chunks.</p>
<p>While most applications will continue to function normally, this introduces an
edge case in the following conditions:</p>
<ul>
<li>No <a href="stream.html#stream_event_data"><code>'data'</code></a> event listener is added.</li>
<li>The <a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> method is never called.</li>
<li>The stream is not piped to any writable destination.</li>
</ul>
<p>For example, consider the following code:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_comment">// WARNING!  BROKEN!</span>
net<span class="sh_symbol">.</span><span class="sh_function">createServer</span><span class="sh_symbol">((</span>socket<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>

  <span class="sh_comment">// we add an 'end' method, but never consume the data</span>
  socket<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
    <span class="sh_comment">// It will never get here.</span>
    socket<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span><span class="sh_string">'The message was received but was not processed.</span><span class="sh_specialchar">\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

<span class="sh_cbracket">}</span><span class="sh_symbol">).</span><span class="sh_function">listen</span><span class="sh_symbol">(</span><span class="sh_number">1337</span><span class="sh_symbol">);</span>
</code></pre>
<p>In versions of Node.js prior to v0.10, the incoming message data would be
simply discarded. However, in Node.js v0.10 and beyond, the socket remains
paused forever.</p>
<p>The workaround in this situation is to call the
<a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> method to begin the flow of data:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_comment">// Workaround</span>
net<span class="sh_symbol">.</span><span class="sh_function">createServer</span><span class="sh_symbol">((</span>socket<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>

  socket<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
    socket<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span><span class="sh_string">'The message was received but was not processed.</span><span class="sh_specialchar">\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

  <span class="sh_comment">// start the flow of data, discarding it.</span>
  socket<span class="sh_symbol">.</span><span class="sh_function">resume</span><span class="sh_symbol">();</span>

<span class="sh_cbracket">}</span><span class="sh_symbol">).</span><span class="sh_function">listen</span><span class="sh_symbol">(</span><span class="sh_number">1337</span><span class="sh_symbol">);</span>
</code></pre>
<p>In addition to new Readable streams switching into flowing mode,
pre-v0.10 style streams can be wrapped in a Readable class using the
<a href="stream.html#stream_readable_wrap_stream"><code>readable.wrap()</code></a> method.</p>
<h3><code>readable.read(0)</code><span><a class="mark" href="stream.html#stream_readable_read_0" id="stream_readable_read_0">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_read_0">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_read_0.md">参与翻译</a></p>
<p>There are some cases where it is necessary to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data. In such cases, it is possible to call <code>readable.read(0)</code>, which will
always return <code>null</code>.</p>
<p>If the internal read buffer is below the <code>highWaterMark</code>, and the
stream is not currently reading, then calling <code>stream.read(0)</code> will trigger
a low-level <a href="stream.html#stream_readable_read_size_1"><code>stream._read()</code></a> call.</p>
<p>While most applications will almost never need to do this, there are
situations within Node.js where this is done, particularly in the
Readable stream class internals.</p>
<h3><code>readable.push('')</code><span><a class="mark" href="stream.html#stream_readable_push" id="stream_readable_push">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/stream.html#stream_readable_push">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/stream/readable_push.md">参与翻译</a></p>
<p>Use of <code>readable.push('')</code> is not recommended.</p>
<p>Pushing a zero-byte string or <code>Buffer</code> to a stream that is not in object mode
has an interesting side effect. Because it <em>is</em> a call to
<a href="stream.html#stream_readable_push_chunk_encoding"><code>readable.push()</code></a>, the call will end the reading process.
However, because the argument is an empty string, no data is added to the
readable buffer so there is nothing for a user to consume.</p>

      </div>
    </div>
  </div>
  <script src="res/api.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>

</body></html>