<!DOCTYPE html>
<!-- saved from url=(0029)net.html -->
<html lang="zh-cmn-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>net | Node.js API 文档</title>
  <link rel="stylesheet" href="res/api.css">
</head>
<body class="alt apidoc" id="api-section-net">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="http://nodejs.cn/">
          Node.js 中文网
        </a>
      </div>
      <ul>
<li><a class="nav-documentation" href="documentation.html">关于本文档</a></li>
<li><a class="nav-synopsis" href="synopsis.html">用法与例子</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a class="nav-assert" href="assert.html">Assert (断言)</a></li>
<li><a class="nav-buffer" href="buffer.html">Buffer</a></li>
<li><a class="nav-addons" href="addons.html">C/C++ 插件</a></li>
<li><a class="nav-child_process" href="child_process.html">Child Processes (子进程)</a></li>
<li><a class="nav-cluster" href="cluster.html">Cluster (集群)</a></li>
<li><a class="nav-cli" href="cli.html">CLI (命令行选项)</a></li>
<li><a class="nav-console" href="console.html">Console (控制台)</a></li>
<li><a class="nav-crypto" href="crypto.html">Crypto (加密)</a></li>
<li><a class="nav-debugger" href="debugger.html">Debugger (调试器)</a></li>
<li><a class="nav-dns" href="dns.html">DNS (域名服务器)</a></li>
<li><a class="nav-domain" href="domain.html">Domain (域)</a></li>
<li><a class="nav-errors" href="errors.html">Error (错误)</a></li>
<li><a class="nav-events" href="events.html">Events (事件)</a></li>
<li><a class="nav-fs" href="fs.html">File System (文件系统)</a></li>
<li><a class="nav-globals" href="globals.html">Global (全局变量)</a></li>
<li><a class="nav-http" href="http.html">HTTP</a></li>
<li><a class="nav-https" href="https.html">HTTPS</a></li>
<li><a class="nav-modules" href="modules.html">Module (模块)</a></li>
<li><a class="nav-net active" href="./net_files/net.htm">Net (网络)</a></li>
<li><a class="nav-os" href="os.html">OS (操作系统)</a></li>
<li><a class="nav-path" href="path.html">Path (路径)</a></li>
<li><a class="nav-process" href="process.html">Process (进程)</a></li>
<li><a class="nav-punycode" href="punycode.html">Punycode</a></li>
<li><a class="nav-querystring" href="querystring.html">Query Strings (查询字符串)</a></li>
<li><a class="nav-readline" href="readline.html">Readline (逐行读取)</a></li>
<li><a class="nav-repl" href="repl.html">REPL (交互式解释器)</a></li>
<li><a class="nav-stream" href="stream.html">Stream (流)</a></li>
<li><a class="nav-string_decoder" href="string_decoder.html">String Decoder (字符串解码器)</a></li>
<li><a class="nav-timers" href="timers.html">Timer (定时器)</a></li>
<li><a class="nav-tls" href="tls.html">TLS/SSL</a></li>
<li><a class="nav-tty" href="tty.html">TTY (终端)</a></li>
<li><a class="nav-dgram" href="dgram.html">UDP/Datagram (数据报)</a></li>
<li><a class="nav-url" href="url.html">URL</a></li>
<li><a class="nav-util" href="util.html">Util (实用工具)</a></li>
<li><a class="nav-v8" href="v8.html">V8</a></li>
<li><a class="nav-vm" href="vm.html">VM (虚拟机)</a></li>
<li><a class="nav-zlib" href="zlib.html">ZLIB (压缩)</a></li>
</ul>
<div class="line"></div>


    </div>

    <div id="column1" data-id="net" class="interior">
      <header>
        <h1>Node.js v6.10.2 文档</h1>
        <div id="gtoc">
          <p>
            <a href="" name="toc">返回文档首页</a>
            <!--<a href="/api/all.html">单页面显示</a> |-->
            <!--<a href="/api/net.json">JSON格式</a> |-->
            <!--<a href="/api/en/net.html">查看英文版</a>-->
          </p>
        </div>
        <hr>
      </header>

      <div id="toc">
        <h2>目录</h2>
        <ul>
<li><span class="stability_2"><a href="net.html#net_net">net (网络)</a></span><ul>
<li><span class="stability_undefined"><a href="net.html#net_class_net_server">net.Server 类</a></span><ul>
<li><span class="stability_undefined"><a href="net.html#net_event_close">'close' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_connection">'connection' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_error">'error' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_listening">'listening' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_address">server.address()</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_close_callback">server.close([callback])</a></span></li>
<li><span class="stability_0"><a href="net.html#net_server_connections">server.connections</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_getconnections_callback">server.getConnections(callback)</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_listen_handle_backlog_callback">server.listen(handle[, backlog][, callback])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_listen_options_callback">server.listen(options[, callback])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_listen_path_backlog_callback">server.listen(path[, backlog][, callback])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_listen_port_hostname_backlog_callback">server.listen([port][, hostname][, backlog][, callback])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_listening">server.listening</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_maxconnections">server.maxConnections</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_ref">server.ref()</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_server_unref">server.unref()</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="net.html#net_class_net_socket">net.Socket 类</a></span><ul>
<li><span class="stability_undefined"><a href="net.html#net_new_net_socket_options">new net.Socket([options])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_close_1">'close' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_connect">'connect' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_data">'data' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_drain">'drain' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_end">'end' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_error_1">'error' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_lookup">'lookup' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_event_timeout">'timeout' 事件</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_address">socket.address()</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_buffersize">socket.bufferSize</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_bytesread">socket.bytesRead</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_byteswritten">socket.bytesWritten</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_connect_options_connectlistener">socket.connect(options[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_connect_path_connectlistener">socket.connect(path[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_connect_port_host_connectlistener">socket.connect(port[, host][, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_connecting">socket.connecting</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_destroy_exception">socket.destroy([exception])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_destroyed">socket.destroyed</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_end_data_encoding">socket.end([data][, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_localaddress">socket.localAddress</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_localport">socket.localPort</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_pause">socket.pause()</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_ref">socket.ref()</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_remoteaddress">socket.remoteAddress</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_remotefamily">socket.remoteFamily</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_remoteport">socket.remotePort</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_resume">socket.resume()</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_setencoding_encoding">socket.setEncoding([encoding])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive([enable][, initialDelay])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_setnodelay_nodelay">socket.setNoDelay([noDelay])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_settimeout_timeout_callback">socket.setTimeout(timeout[, callback])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_unref">socket.unref()</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_socket_write_data_encoding_callback">socket.write(data[, encoding][, callback])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="net.html#net_net_connect_options_connectlistener">net.connect(options[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_connect_path_connectlistener">net.connect(path[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_connect_port_host_connectlistener">net.connect(port[, host][, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_createconnection_options_connectlistener">net.createConnection(options[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_createconnection_path_connectlistener">net.createConnection(path[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_createconnection_port_host_connectlistener">net.createConnection(port[, host][, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_createserver_options_connectionlistener">net.createServer([options][, connectionListener])</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_isip_input">net.isIP(input)</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_isipv4_input">net.isIPv4(input)</a></span></li>
<li><span class="stability_undefined"><a href="net.html#net_net_isipv6_input">net.isIPv6(input)</a></span></li>
</ul>
</li>
</ul>

      </div>

      <div id="apicontent">
        <h1>net (网络)<span><a class="mark" href="net.html#net_net" id="net_net">#</a></span></h1><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net.md">参与翻译</a></p>
<pre class="api_stability api_stability_2 sh_sourceCode">稳定性<span class="sh_symbol">:</span> <span class="sh_number">2</span> <span class="sh_symbol">-</span> 稳定的</pre><p><code>net</code> 模块给你提供了一个异步的网络封装. 它包含创建服务器和客户端（称为流）的功能。你可以这样使用这个模块 <code>require('net');</code>.</p>
<h2>net.Server 类<span><a class="mark" href="net.html#net_class_net_server" id="net_class_net_server">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_class_net_server">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/class_net_server.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>本类用于创建TCP或本地服务器.</p>
<p><code>net.Server</code> 是一个有着以下事件的<a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> :</p>
<h3>'close' 事件<span><a class="mark" href="net.html#net_event_close" id="net_event_close">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_close">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_close.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><p>当服务器关闭时被触发。注意：如果还有连接存在的话，直到所有的连接都关闭时，这个事件才被触发。</p>
<h3>'connection' 事件<span><a class="mark" href="net.html#net_event_connection" id="net_event_connection">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_connection">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_connection.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><a href="net.html#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> 连接对象</li>
</ul>
<p>当一个新连接建立的时候被触发。<code>socket</code>是<code>net.Socket</code>的一个实例.</p>
<h3>'error' 事件<span><a class="mark" href="net.html#net_event_error" id="net_event_error">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_error">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_error.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a></li>
</ul>
<p>当错误发生时触发。
不像 <a href="net.html#net_class_net_socket"><code>net.Socket</code></a>，<a href="net.html#net_event_close"><code>'close'</code></a> 事件不会紧接该事件触发，除非 <a href="net.html#net_server_close_callback"><code>server.close()</code></a> 被手动调用。
可在 <a href="net.html#net_server_listen_port_hostname_backlog_callback"><code>server.listen()</code></a> 的讨论中查看相关例子。</p>
<h3>'listening' 事件<span><a class="mark" href="net.html#net_event_listening" id="net_event_listening">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_listening">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_listening.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当调用<code>server.listen</code>后，服务器被绑定时触发.</p>
<h3>server.address()<span><a class="mark" href="net.html#net_server_address" id="net_server_address">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_address">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_address.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>操作系统返回绑定的服务器的IP地址， IP地址协议簇，端口号 .
当查看一个系统赋予的IP地址时，有利于发现被分配给了哪个端口号。
返回对象的以下属性<code>port</code>, <code>family</code>, and <code>address</code> :
<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code></p>
<p>例子:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">var</span> server <span class="sh_symbol">=</span> net<span class="sh_symbol">.</span><span class="sh_function">createServer</span><span class="sh_symbol">((</span>socket<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  socket<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">(</span><span class="sh_string">'goodbye</span><span class="sh_specialchar">\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">).</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'error'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>err<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_comment">// handle errors here</span>
  <span class="sh_keyword">throw</span> err<span class="sh_symbol">;</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

<span class="sh_comment">// grab a random port.</span>
server<span class="sh_symbol">.</span><span class="sh_function">listen</span><span class="sh_symbol">(()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'opened server on'</span><span class="sh_symbol">,</span> server<span class="sh_symbol">.</span><span class="sh_function">address</span><span class="sh_symbol">());</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>直到<code>'listening'</code> 事件被触发后，才可以调用<code>server.address()</code> .</p>
<h3>server.close([callback])<span><a class="mark" href="net.html#net_server_close_callback" id="net_server_close_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_close_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_close_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>使服务器停止接受新连接，只保持现存的连接。这个函数是异步的，当所有连接
断开时，服务器关闭并且发出<a href="net.html#net_event_close"><code>'close'</code></a>事件。一旦<code>'close'</code>事件发生，可选的
<code>callback</code>参数将被调用。不像<code>'close'</code>事件一样，它将在错误之后被调用，因为
它唯一的缘由是服务器还没打开呢，就被关闭。</p>
<h3>server.connections<span><a class="mark" href="net.html#net_server_connections" id="net_server_connections">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_connections">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_connections.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.2.0</span>
<span>废弃于: v0.9.7 </span>
</div><pre class="api_stability api_stability_0 sh_sourceCode">稳定性<span class="sh_symbol">:</span> <span class="sh_number">0</span> <span class="sh_symbol">-</span> 废弃的<span class="sh_symbol">:</span> 使用 <a href="net.html#net_server_getconnections_callback"><code>server<span class="sh_symbol">.</span><span class="sh_function">getConnections</span><span class="sh_symbol">()</span></code></a> 代替。</pre><p>服务器上现在同时存在的连接的数目.</p>
<p>当用<a href="child_process.html#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a>向一个子进程发出socket连接时，这将变成<code>null</code>。
当poll新进程和获取活着的连接的数目时，可以用异步的<code>server.getConnections</code> 代替.</p>
<h3>server.getConnections(callback)<span><a class="mark" href="net.html#net_server_getconnections_callback" id="net_server_getconnections_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_getconnections_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_getconnections_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.7</span>
</div><p>异步的获取服务器当前共同存在的连接的数目。
当sockets被发送forks时工作。</p>
<p>Callback参数可以是<code>err</code> 或者 <code>count</code>。</p>
<h3>server.listen(handle[, backlog][, callback])<span><a class="mark" href="net.html#net_server_listen_handle_backlog_callback" id="net_server_listen_handle_backlog_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_listen_handle_backlog_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_listen_handle_backlog_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.5.10</span>
</div><ul>
<li><code>handle</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a></li>
<li><code>backlog</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a></li>
</ul>
<p><code>handle</code> 对象可以被设置为服务器或者是socket（任何有着下标<code>_handle</code>属性的对象）, 或者一个 <code>{fd: &lt;n&gt;}</code> 对象.</p>
<p>这可能会导致服务器在特定的handle上接受连接，
但是它被认为文件描述器或者处理器已经被绑定到一个端口或者socket域上。</p>
<p>Windows系统不支持监听文件描述器。</p>
<p>这个函数是异步的。当服务器已经被绑定时，
<a href="net.html#net_event_listening"><code>'listening'</code></a> 事件将被触发.
最后一个参数<code>callback</code>将被添加为 <a href="net.html#net_event_listening"><code>'listening'</code></a>事件的一个监听器 .</p>
<p><code>backlog</code> 参数表现的同
<a href="net.html#net_server_listen_port_hostname_backlog_callback"><code>server.listen([port][, hostname][, backlog][, callback])</code></a>一样.</p>
<h3>server.listen(options[, callback])<span><a class="mark" href="net.html#net_server_listen_options_callback" id="net_server_listen_options_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_listen_options_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_listen_options_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div><ul>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> - 必须. 支持以下参数：<ul>
<li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> - 可选.</li>
<li><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> - 可选.</li>
<li><code>backlog</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> - 可选.</li>
<li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> - 可选.</li>
<li><code>exclusive</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> - 可选.</li>
</ul>
</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> - 可选.</li>
</ul>
<p><code>port</code>, <code>host</code>, 和 <code>backlog</code> 是 <code>options</code> 的参数,
可选的 callback 函数, 表现的好像它们在调用
<a href="net.html#net_server_listen_port_hostname_backlog_callback"><code>server.listen([port][, hostname][, backlog][, callback])</code></a>.
另外,  <code>path</code> 参数可以用于确定UNIX套接字。</p>
<p>如果 <code>exclusive</code> 是 <code>false</code> (默认), 那么cluster的worker对象将利用相同的基础处理方法，
允许共享连接处理机制。当<code>exclusive</code> 是 <code>true</code>, 处理方法不被共享，企图共享端口将导致错误。
下面是一个监听专用端口的例子：</p>
<pre class="sh_sourceCode"><code class="lang-js">server<span class="sh_symbol">.</span><span class="sh_function">listen</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>
  host<span class="sh_symbol">:</span> <span class="sh_string">'localhost'</span><span class="sh_symbol">,</span>
  port<span class="sh_symbol">:</span> <span class="sh_number">80</span><span class="sh_symbol">,</span>
  exclusive<span class="sh_symbol">:</span> <span class="sh_keyword">true</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p><em>注意</em>: <code>server.listen()</code> 方法可能被多次调用. 每个随后的
调用将利用提供的参数 <em>重新打开</em> 服务器。</p>
<h3>server.listen(path[, backlog][, callback])<span><a class="mark" href="net.html#net_server_listen_path_backlog_callback" id="net_server_listen_path_backlog_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_listen_path_backlog_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_listen_path_backlog_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a></li>
<li><code>backlog</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a></li>
</ul>
<p>在给定的<code>path</code>路径上，开启一个监听连接的本地socket服务器。</p>
<p>这个函数是异步的. 当服务器被已经绑定时<a href="net.html#net_event_listening"><code>'listening'</code></a> 事件将被触发。最后一个参数
<code>callback</code> 将被添加为<a href="net.html#net_event_listening"><code>'listening'</code></a>事件的监听器.</p>
<p>在UNIX上, 本地域通常被称为UNIX域. 路径是文件系统路径名。
它被截断至<code>sizeof(sockaddr_un.sun_path)</code>个字节，减去一。
它根据操作系统的不同，在91和107个字节之间变动。典型的值为在Linux上
为107，在OS X上为103.路径遵循相同的命名规则和权限检查，这会在文件生成的时候进行，
可以在文件系统中可视，并且<em>直到不连接的时候才被允许</em>。</p>
<p>在Windows系统上，本地域用具名管道实现。路径<em>必须</em>是<code>\\?\pipe\</code>或<code>\\.\pipe\</code>的入口。
任何字符都是允许的，但是有一些处理可能会影响管道的名字，例如解析<code>..</code>序列。
无论表现如何，管道命名空间是平的。管道<em>不允许</em>被移除，当他们的最后一个引用被关闭的时候。
不要忘记JavaScript字符串转义需要路径用双斜线，例如</p>
<pre class="sh_sourceCode"><code class="lang-js">net<span class="sh_symbol">.</span><span class="sh_function">createServer</span><span class="sh_symbol">().</span><span class="sh_function">listen</span><span class="sh_symbol">(</span>
    path<span class="sh_symbol">.</span><span class="sh_function">join</span><span class="sh_symbol">(</span><span class="sh_string">'</span><span class="sh_specialchar">\\\\</span><span class="sh_string">?</span><span class="sh_specialchar">\\</span><span class="sh_string">pipe'</span><span class="sh_symbol">,</span> process<span class="sh_symbol">.</span><span class="sh_function">cwd</span><span class="sh_symbol">(),</span> <span class="sh_string">'myctl'</span><span class="sh_symbol">))</span>
</code></pre>
<p><code>backlog</code>参数表现地跟
<a href="net.html#net_server_listen_port_hostname_backlog_callback"><code>server.listen([port][, hostname][, backlog][, callback])</code></a>一样。</p>
<p><em>注意</em>: <code>server.listen()</code>方法可以被多次调用。每个随后的调用将
用提供的参数<em>重新打开</em>服务器.</p>
<h3>server.listen([port][, hostname][, backlog][, callback])<span><a class="mark" href="net.html#net_server_listen_port_hostname_backlog_callback" id="net_server_listen_port_hostname_backlog_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_listen_port_hostname_backlog_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_listen_port_hostname_backlog_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>在特定的<code>port</code>和<code>hostname</code>开始接受连接. 如果<code>hostname</code>被省略，当IPv6可用的时候，服务器将
接受所有的IPv6地址(<code>::</code>)或者所有的 IPv4 地址 (<code>0.0.0.0</code>)。省略端口参数，或者用的端口值为<code>0</code>，
将被操作系统赋予一个任意的端口，这可以在<code>'listening'</code>事件被触发后，用<code>server.address().port</code>
来获取。</p>
<p>Backlog 是等待连接的队列长度的最大值。实际的长度在Linux上将由操作系统通过系统设置如
<code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code> 来确定。默认值为511（而不是512）。</p>
<p>这个函数是异步的。网服务器被绑定时，<a href="net.html#net_event_listening"><code>'listening'</code></a>事件被触发。最后一个参数，
<code>callback</code>将被加做<a href="net.html#net_event_listening"><code>'listening'</code></a>事件的监听器。</p>
<p>一些用户运行的一个问题是得到<code>EADDRINUSE</code>错误。这意味这另一个服务器已经运行在请求的端口。
处理这个问题的一个方式是等待一秒再次尝试运行：</p>
<pre class="sh_sourceCode"><code class="lang-js">server<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'error'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>e<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>e<span class="sh_symbol">.</span>code <span class="sh_symbol">==</span> <span class="sh_string">'EADDRINUSE'</span><span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
    console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'Address in use, retrying...'</span><span class="sh_symbol">);</span>
    <span class="sh_function">setTimeout</span><span class="sh_symbol">(()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
      server<span class="sh_symbol">.</span><span class="sh_function">close</span><span class="sh_symbol">();</span>
      server<span class="sh_symbol">.</span><span class="sh_function">listen</span><span class="sh_symbol">(</span>PORT<span class="sh_symbol">,</span> HOST<span class="sh_symbol">);</span>
    <span class="sh_cbracket">}</span><span class="sh_symbol">,</span> <span class="sh_number">1000</span><span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>(注意: Node.js中所有的socket都被设置为<code>SO_REUSEADDR</code>.)</p>
<p><em>注意</em>: <code>server.listen()</code>方法可以被多次调用。每个随后的调用将
用提供的参数<em>重新打开</em>服务器.</p>
<h3>server.listening<span><a class="mark" href="net.html#net_server_listening" id="net_server_listening">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_listening">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_listening.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v5.7.0</span>
</div><p>一个布尔值，代表服务器是否在监听连接。</p>
<h3>server.maxConnections<span><a class="mark" href="net.html#net_server_maxconnections" id="net_server_maxconnections">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_maxconnections">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_maxconnections.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.2.0</span>
</div><p>设定这个属性，当服务器的连接超过此值时，新的连接将被拒绝。</p>
<p>一旦连接已经用<a href="child_process.html#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a>被发送到子进程时，它不被推荐使用。</p>
<h3>server.ref()<span><a class="mark" href="net.html#net_server_ref" id="net_server_ref">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_ref">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_ref.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><p>与<code>unref</code>相反, 在一个原先是<code>unref</code>的服务器上调用 <code>ref</code> 将<em>不会</em>允许程序退出 
即使它是唯一剩下的服务器（默认行为）。如果服务器已经是<code>ref</code>的了，再次调用<code>ref</code>将
不会产生效果。</p>
<p>返回<code>server</code>.</p>
<h3>server.unref()<span><a class="mark" href="net.html#net_server_unref" id="net_server_unref">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_server_unref">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/server_unref.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><p>在服务器上调用 <code>unref</code>将允许程序当这是事件系统中唯一存活的服务器时退出。
如果服务器已经是<code>unref</code>，再次调用<code>unref</code>没有任何效应.</p>
<p>返回<code>server</code>.</p>
<h2>net.Socket 类<span><a class="mark" href="net.html#net_class_net_socket" id="net_class_net_socket">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_class_net_socket">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/class_net_socket.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.3.4</span>
</div><p>这个对象是TCP或者本地socket的一个抽象。<code>net.Socket</code>实例实现了
一个双工流接口。它们可以由用户创建用于客户端（和<a href="net.html#net_socket_connect_options_connectlistener"><code>connect()</code></a>），
或者是由Node.js创建，用于通过一个服务器的<code>'connection'</code>事件传参给用户。</p>
<h3>new net.Socket([options])<span><a class="mark" href="net.html#net_new_net_socket_options" id="net_new_net_socket_options">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_new_net_socket_options">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/new_net_socket_options.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.3.4</span>
</div><p>构造一个新的socket对象。</p>
<p><code>options</code> 是一个对象，有着以下默认值:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_cbracket">{</span>
  fd<span class="sh_symbol">:</span> <span class="sh_keyword">null</span><span class="sh_symbol">,</span>
  allowHalfOpen<span class="sh_symbol">:</span> <span class="sh_keyword">false</span><span class="sh_symbol">,</span>
  readable<span class="sh_symbol">:</span> <span class="sh_keyword">false</span><span class="sh_symbol">,</span>
  writable<span class="sh_symbol">:</span> <span class="sh_keyword">false</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p><code>fd</code> 允许你指定socket的存在的文件描述器。
设定 <code>readable</code> 和/或 <code>writable</code> 为 <code>true</code> 来允许在这个socket上进行读和/或写。
(注意: 只有当 <code>fd</code> 被传参时，才工作).
关于 <code>allowHalfOpen</code>, 请参照 <code>createServer()</code> 和 <code>'end'</code> 事件.</p>
<p><code>net.Socket</code> 是 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> 实例，有以下事件:</p>
<h3>'close' 事件<span><a class="mark" href="net.html#net_event_close_1" id="net_event_close_1">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_close_1">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_close_1.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>had_error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> <code>true</code> 如果socket有传输错误的话。</li>
</ul>
<p>一旦socket完全关闭时被触发。参数<code>had_error</code>是一个布尔值，代表socket关闭是否是由于传输错误。</p>
<h3>'connect' 事件<span><a class="mark" href="net.html#net_event_connect" id="net_event_connect">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_connect">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_connect.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当socket连接完全建立时，被触发。
详细请看<a href="net.html#net_socket_connect_options_connectlistener"><code>connect()</code></a>.</p>
<h3>'data' 事件<span><a class="mark" href="net.html#net_event_data" id="net_event_data">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_data">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_data.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>当接收到数据时被触发。 参数 <code>data</code> 是 <code>Buffer</code> 或者 <code>String</code> 类型。
数据的编码由<code>socket.setEncoding()</code>设定。（查看 <a href="stream.html#stream_class_stream_readable">Readable Stream</a>一节获取更多信息）</p>
<p>注意：如果当<code>Socket</code>触发<code>'data'</code>事件时，没有监听器在监听，这导致 <strong>数据可能会丢失</strong>。</p>
<h3>'drain' 事件<span><a class="mark" href="net.html#net_event_drain" id="net_event_drain">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_drain">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_drain.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当写入缓存为空时被触发。可以被用于降速上传。</p>
<p>查看：<code>socket.write()</code>的返回值。</p>
<h3>'end' 事件<span><a class="mark" href="net.html#net_event_end" id="net_event_end">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_end">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_end.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当socket连接的另一端发出FIN包时被触发。</p>
<p>默认情况下(<code>allowHalfOpen == false</code>)，socket连接一旦将要写完写队列，就会破坏
它的文件描述器。然而，通过设置<code>allowHalfOpen == true</code>，socket将不会自动的结束它
这一端，并且允许用户写入任意大小的数据，并且附加说明用户需要手动的调用<code>end()</code>在他们那一端。</p>
<h3>'error' 事件<span><a class="mark" href="net.html#net_event_error_1" id="net_event_error_1">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_error_1">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_error_1.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a></li>
</ul>
<p>当错误发生时被触发。<code>'close'</code>事件将在之后被直接触发。</p>
<h3>'lookup' 事件<span><a class="mark" href="net.html#net_event_lookup" id="net_event_lookup">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_lookup">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_lookup.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.11.3</span>
</div><p>在解析域名之后，进行连接之前被触发。 
不能用于UNIX sockets. </p>
<ul>
<li><code>err</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;Null&gt;</a> 错误对象.  查看 <a href="dns.html#dns_dns_lookup_hostname_options_callback"><code>dns.lookup()</code></a>.</li>
<li><code>address</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> IP地址.</li>
<li><code>family</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;Null&gt;</a> IP地址类型.  See <a href="dns.html#dns_dns_lookup_hostname_options_callback"><code>dns.lookup()</code></a>.</li>
<li><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;String&gt;</a> 域名.</li>
</ul>
<h3>'timeout' 事件<span><a class="mark" href="net.html#net_event_timeout" id="net_event_timeout">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_event_timeout">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/event_timeout.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当socket在不活动中超时时被触发。这仅仅表明socket已经处于关闭中，用户需要手动关闭连接。 </p>
<p>查看更多: <a href="net.html#net_socket_settimeout_timeout_callback"><code>socket.setTimeout()</code></a></p>
<h3>socket.address()<span><a class="mark" href="net.html#net_socket_address" id="net_socket_address">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_address">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_address.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>返回操作系统报告的绑定的socket的IP地址，IP地址族和端口。
返回有着以下三个属性的对象，例如
<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code></p>
<h3>socket.bufferSize<span><a class="mark" href="net.html#net_socket_buffersize" id="net_socket_buffersize">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_buffersize">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_buffersize.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.3.8</span>
</div><p><code>net.Socket</code> 有这样的一个性质，即 <code>socket.write()</code> 总是在运行。这是为了帮助用户运行地更快。
计算机不能总是保持一定量的数据写入socket--网络连接肯能会变慢。Node.js将内部的把要写入socket的
数据排队，然后在可能的时候将之通过网络发出。(在内部，它在socket文件描述器上轮询，等待可写）</p>
<p>这样内部缓存的结果是使用的内存将增长。这个性质表明了当前缓存的等待被发送的字符的数量。
（字符的数量近似与等待被写的字节的数目，但是缓存中可能包含字符串，字符串是懒散编码的，
因此字节的确切的数目是未知的）</p>
<p>体验过大的或增长的<code>bufferSize</code>的用户应该在他们的程序中试图用<a href="net.html#net_socket_pause"><code>pause()</code></a>和<a href="net.html#net_socket_resume"><code>resume()</code></a>
"限制" 数据的增长。</p>
<h3>socket.bytesRead<span><a class="mark" href="net.html#net_socket_bytesread" id="net_socket_bytesread">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_bytesread">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_bytesread.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.5.3</span>
</div><p>收到的字节的数量.</p>
<h3>socket.bytesWritten<span><a class="mark" href="net.html#net_socket_byteswritten" id="net_socket_byteswritten">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_byteswritten">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_byteswritten.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.5.3</span>
</div><p>发送的字节的数量.</p>
<h3>socket.connect(options[, connectListener])<span><a class="mark" href="net.html#net_socket_connect_options_connectlistener" id="net_socket_connect_options_connectlistener">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_connect_options_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_connect_options_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>根据给定的socket参数，打开连接.</p>
<p>对于TCP socket, <code>options</code>参数应该是一个对象，它确定了:</p>
<ul>
<li><p><code>port</code>: 客户端应该连接的端口(必须).</p>
</li>
<li><p><code>host</code>: 客户端应该连接的host主机. 默认为<code>'localhost'</code>.</p>
</li>
<li><p><code>localAddress</code>: 为了网络连接应该绑定的本地接口。</p>
</li>
<li><p><code>localPort</code>: 为了网络连接应该绑定的本地端口.</p>
</li>
<li><p><code>family</code> : IP地址族的.默认为 <code>4</code>.</p>
</li>
<li><p><code>hints</code>: <a href="dns.html#dns_supported_getaddrinfo_flags"><code>dns.lookup()</code> hints</a>. 默认为 <code>0</code>.</p>
</li>
<li><p><code>lookup</code> : 可定制查询函数. 默认为 <code>dns.lookup</code>.</p>
</li>
</ul>
<p>对于本地域socket, <code>options</code> 参数 应当是一个参数，它确定了:</p>
<ul>
<li><code>path</code>: 客户端应该连接的路径 (必须).</li>
</ul>
<p>正常地，这个方法不是必要的，因为<code>net.createConnection</code>打开了socket。 
如果你要实现自己定制的socket才用这个方法。</p>
<p>这个函数是异步的。当<a href="net.html#net_event_connect"><code>'connect'</code></a>事件被触发时，socket已经建立。
如果有一个问题连接，<code>'connect'</code>事件将不会被触发，有异常的<a href="net.html#net_event_error_1"><code>'error'</code></a>事件
将被触发。</p>
<p><code>connectListener</code>参数将被添加为<a href="net.html#net_event_connect"><code>'connect'</code></a>事件的监听器。</p>
<h3>socket.connect(path[, connectListener])<span><a class="mark" href="net.html#net_socket_connect_path_connectlistener" id="net_socket_connect_path_connectlistener">#</a></span></h3>
<h3>socket.connect(port[, host][, connectListener])<span><a class="mark" href="net.html#net_socket_connect_port_host_connectlistener" id="net_socket_connect_port_host_connectlistener">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_connect_port_host_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_connect_port_host_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>作为<a href="net.html#net_socket_connect_options_connectlistener"><code>socket.connect(options[, connectListener])</code></a>,
options参数有<code>{port: port, host: host}</code> 或者 <code>{path: path}</code>.</p>
<h3>socket.connecting<span><a class="mark" href="net.html#net_socket_connecting" id="net_socket_connecting">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_connecting">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_connecting.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v6.1.0</span>
</div><p>如果是 <code>true</code> - <a href="net.html#net_socket_connect_options_connectlistener"><code>socket.connect(options[, connectListener])</code></a> 被调用，
并且还没有完成。 在触发<code>connect</code>事件和/或调用<a href="net.html#net_socket_connect_options_connectlistener"><code>socket.connect(options[, connectListener])</code></a>
的回调函数之前，将被设置为<code>false</code> 。</p>
<h3>socket.destroy([exception])<span><a class="mark" href="net.html#net_socket_destroy_exception" id="net_socket_destroy_exception">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_destroy_exception">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_destroy_exception.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>确保没有更多的I/O操作在这个socket上。只有必要的以防出错（解析错误等等）。</p>
<p>如果<code>exception</code>被指定，<a href="net.html#net_event_error_1"><code>'error'</code></a>将被触发并且，任何监听此事件的监听器都会收到
<code>exception</code>为参数。</p>
<h3>socket.destroyed<span><a class="mark" href="net.html#net_socket_destroyed" id="net_socket_destroyed">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_destroyed">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_destroyed.md">参与翻译</a></p>
<p>一个布尔值，表明连接是否被破坏。一旦连接被破坏，
就没有数据可以用它来传输。</p>
<h3>socket.end([data][, encoding])<span><a class="mark" href="net.html#net_socket_end_data_encoding" id="net_socket_end_data_encoding">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_end_data_encoding">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_end_data_encoding.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>半关闭socket. 即它将发送一个FIN包. 服务器仍然可能发送一些数据。</p>
<p>如果<code>data</code>是指定的，它等价于调用<code>socket.write(data, encoding)</code>，
之后在调用<code>socket.end()</code>.</p>
<h3>socket.localAddress<span><a class="mark" href="net.html#net_socket_localaddress" id="net_socket_localaddress">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_localaddress">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_localaddress.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.6</span>
</div><p>远程客户端连接的本地IP地址的字符串表示。 例如, 如果你监听<code>'0.0.0.0'</code> 而客户端连接的是
<code>'192.168.1.1'</code>, 最后的值是 <code>'192.168.1.1'</code>.</p>
<h3>socket.localPort<span><a class="mark" href="net.html#net_socket_localport" id="net_socket_localport">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_localport">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_localport.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.6</span>
</div><p>本地端口的数字表示. 例如,
<code>80</code> 或者 <code>21</code>.</p>
<h3>socket.pause()<span><a class="mark" href="net.html#net_socket_pause" id="net_socket_pause">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_pause">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_pause.md">参与翻译</a></p>
<p>暂停读取数据。意味着, <a href="net.html#net_event_data"><code>'data'</code></a> 事件将不会被触发.
对上传进行限制时有用.</p>
<h3>socket.ref()<span><a class="mark" href="net.html#net_socket_ref" id="net_socket_ref">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_ref">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_ref.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><p>与<code>unref</code>相反, 在一个原先是<code>unref</code>的socket上调用 <code>ref</code> 将<em>不会</em>允许程序退出 
即使它是唯一剩下的socket（默认行为）。如果socket已经是<code>ref</code>的了，再次调用<code>ref</code>将
不会产生效果。</p>
<p>返回<code>socket</code>.</p>
<h3>socket.remoteAddress<span><a class="mark" href="net.html#net_socket_remoteaddress" id="net_socket_remoteaddress">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_remoteaddress">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_remoteaddress.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.5.10</span>
</div><p>远程IP地址的字符串表示. 例如,
<code>'74.125.127.100'</code> 或者 <code>'2001:4860:a005::68'</code>. 如果socket
被破坏掉的话（比如，客户端失去连接），值可能是<code>undefined</code>.</p>
<h3>socket.remoteFamily<span><a class="mark" href="net.html#net_socket_remotefamily" id="net_socket_remotefamily">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_remotefamily">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_remotefamily.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div><p>远程IP地址簇的字符串表示. <code>'IPv4'</code> 或 <code>'IPv6'</code>.</p>
<h3>socket.remotePort<span><a class="mark" href="net.html#net_socket_remoteport" id="net_socket_remoteport">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_remoteport">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_remoteport.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.5.10</span>
</div><p>远程端口的数字表示.例如,
<code>80</code> or <code>21</code>.</p>
<h3>socket.resume()<span><a class="mark" href="net.html#net_socket_resume" id="net_socket_resume">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_resume">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_resume.md">参与翻译</a></p>
<p>在调用<a href="net.html#net_socket_pause"><code>pause()</code></a>之后恢复读取.</p>
<h3>socket.setEncoding([encoding])<span><a class="mark" href="net.html#net_socket_setencoding_encoding" id="net_socket_setencoding_encoding">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_setencoding_encoding">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_setencoding_encoding.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>把socket的编码设置为<a href="stream.html#stream_class_stream_readable">Readable Stream</a>. 查看
<a href="stream.html#stream_readable_setencoding_encoding"><code>stream.setEncoding()</code></a> 获取更多信息.</p>
<h3>socket.setKeepAlive([enable][, initialDelay])<span><a class="mark" href="net.html#net_socket_setkeepalive_enable_initialdelay" id="net_socket_setkeepalive_enable_initialdelay">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_setkeepalive_enable_initialdelay">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_setkeepalive_enable_initialdelay.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div><p>允许/禁止keep-alive功能, 并且可选地在第一个keep-alive探针发送到空闲的socket上
之前，设置初始时延。
<code>enable</code>默认是<code>false</code>.</p>
<p>设置 <code>initialDelay</code>(毫秒)来设置在最后一个包收到之后和第一个keep-alive探针之前
的时延。设置初始时延为0将不改变默认设置的值。值默认为0.</p>
<p>返回 <code>socket</code>.</p>
<h3>socket.setNoDelay([noDelay])<span><a class="mark" href="net.html#net_socket_setnodelay_nodelay" id="net_socket_setnodelay_nodelay">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_setnodelay_nodelay">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_setnodelay_nodelay.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>禁止Nagele算法。默认TCP连接使用Nagle算法，它们在发送数据之前先缓存。
设置<code>noDelay</code>为<code>true</code>将在<code>socket.write()</code>每次被调用时，立即发送数据。
<code>noDelay</code> 默认为 <code>true</code>.</p>
<p>返回 <code>socket</code>.</p>
<h3>socket.setTimeout(timeout[, callback])<span><a class="mark" href="net.html#net_socket_settimeout_timeout_callback" id="net_socket_settimeout_timeout_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_settimeout_timeout_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_settimeout_timeout_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>在不活动的socket<code>timeout</code>几毫秒之后，设置socket为超时。
默认，<code>net.Socket</code>没有超时。</p>
<p>当一个空闲的超时被触发时，socket将收到<a href="net.html#net_event_timeout"><code>'timeout'</code></a>事件，但是连接并不会停止。
用户必须手动的<a href="net.html#net_socket_end_data_encoding"><code>end()</code></a>或者<a href="net.html#net_socket_destroy_exception"><code>destroy()</code></a>这个socket。</p>
<p>如果<code>timeout</code>的值为0，那么存在的空闲的超时将被禁止。</p>
<p>可选的<code>callback</code>参数将被添加为<a href="net.html#net_event_timeout"><code>'timeout'</code></a>事件的一次行监听器。</p>
<p>返回<code>socket</code>.</p>
<h3>socket.unref()<span><a class="mark" href="net.html#net_socket_unref" id="net_socket_unref">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_unref">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_unref.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><p>在socket上调用 <code>unref</code>将允许程序当这是事件系统中唯一存活的socket时退出。
如果socket已经是<code>unref</code>，再次调用<code>unref</code>没有任何效应.</p>
<p>返回 <code>socket</code>.</p>
<h3>socket.write(data[, encoding][, callback])<span><a class="mark" href="net.html#net_socket_write_data_encoding_callback" id="net_socket_write_data_encoding_callback">#</a></span></h3><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_socket_write_data_encoding_callback">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/socket_write_data_encoding_callback.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>在socket上发送数据。第二个参数制定字符串的编码格式--默认是UTF8编码。</p>
<p>如果全部数据被成功地清空到内核缓存，返回<code>true</code>。如果全部或部分数据在用户内存中形成队列，将
返回<code>false</code>。
当buffer再次空白时，<a href="net.html#net_event_drain"><code>'drain'</code></a> 事件将被触发。</p>
<p>当数据最终被写出时（这可能不是立即发生的），可选的<code>callback</code>参数将被执行。</p>
<h2>net.connect(options[, connectListener])<span><a class="mark" href="net.html#net_net_connect_options_connectlistener" id="net_net_connect_options_connectlistener">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_connect_options_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_connect_options_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.7.0</span>
</div><p>一个生产器函数，将返回一个新的 <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 并且自动的根据所提供的<code>options</code> 参数进行连接。</p>
<p>options参数将被传递到<a href="net.html#net_class_net_socket"><code>net.Socket</code></a>构造函数和<a href="net.html#net_socket_connect_options_connectlistener"><code>socket.connect</code></a>方法两个地方。</p>
<p><code>connectListener</code>参数将一次被用作监听器来监听<a href="net.html#net_event_connect"><code>'connect'</code></a>事件。</p>
<p>下面有一个例子来阐述之前描述过的响应服务器的客户端的用法</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> net <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'net'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">const</span> client <span class="sh_symbol">=</span> net<span class="sh_symbol">.</span><span class="sh_function">connect</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>port<span class="sh_symbol">:</span> <span class="sh_number">8124</span><span class="sh_cbracket">}</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_comment">// 'connect' listener</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'connected to server!'</span><span class="sh_symbol">);</span>
  client<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'world!</span><span class="sh_specialchar">\r\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
client<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>data<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>data<span class="sh_symbol">.</span><span class="sh_function">toString</span><span class="sh_symbol">());</span>
  client<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">();</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
client<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'disconnected from server'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>为了连接<code>/tmp/echo.sock</code>的socket，第二行应改为</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> client <span class="sh_symbol">=</span> net<span class="sh_symbol">.</span><span class="sh_function">connect</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>path<span class="sh_symbol">:</span> <span class="sh_string">'/tmp/echo.sock'</span><span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h2>net.connect(path[, connectListener])<span><a class="mark" href="net.html#net_net_connect_path_connectlistener" id="net_net_connect_path_connectlistener">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_connect_path_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_connect_path_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>一个生成器函数，返回一个新的 Unix <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 并且自动的
连接到所提供的<code>path</code>参数.</p>
<p><code>connectListener</code>参数将一次被用作监听器来监听<a href="net.html#net_event_connect"><code>'connect'</code></a>事件。</p>
<h2>net.connect(port[, host][, connectListener])<span><a class="mark" href="net.html#net_net_connect_port_host_connectlistener" id="net_net_connect_port_host_connectlistener">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_connect_port_host_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_connect_port_host_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>一个生成器函数，返回一个新的 Unix <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 并且自动的
连接到所提供的 <code>port</code>和<code>host</code>参数.</p>
<p>如果<code>host</code>被省略，<code>'localhost'</code> 将被默认使用。</p>
<p><code>connectListener</code>参数将一次被用作监听器来监听<a href="net.html#net_event_connect"><code>'connect'</code></a>事件。</p>
<h2>net.createConnection(options[, connectListener])<span><a class="mark" href="net.html#net_net_createconnection_options_connectlistener" id="net_net_createconnection_options_connectlistener">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_createconnection_options_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_createconnection_options_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>一个生产器函数，将返回一个新的 <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 并且自动的根据所提供的<code>options</code> 参数进行连接。</p>
<p>options参数将被传递到<a href="net.html#net_class_net_socket"><code>net.Socket</code></a>构造函数和<a href="net.html#net_socket_connect_options_connectlistener"><code>socket.connect</code></a>方法两个地方。</p>
<p>在socket创建之后，连接建立之前，传递<code>timeout</code>作为参数将调用<a href="net.html#net_socket_settimeout_timeout_callback"><code>socket.setTimeout()</code></a>。</p>
<p><code>connectListener</code>参数将一次被用作监听器来监听<a href="net.html#net_event_connect"><code>'connect'</code></a>事件。</p>
<p>下面有一个例子来阐述之前描述过的响应服务器的客户端的用法</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> net <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'net'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">const</span> client <span class="sh_symbol">=</span> net<span class="sh_symbol">.</span><span class="sh_function">createConnection</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>port<span class="sh_symbol">:</span> <span class="sh_number">8124</span><span class="sh_cbracket">}</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_comment">//'connect' listener</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'connected to server!'</span><span class="sh_symbol">);</span>
  client<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'world!</span><span class="sh_specialchar">\r\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
client<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>data<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>data<span class="sh_symbol">.</span><span class="sh_function">toString</span><span class="sh_symbol">());</span>
  client<span class="sh_symbol">.</span><span class="sh_function">end</span><span class="sh_symbol">();</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
client<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'disconnected from server'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>为了连接<code>/tmp/echo.sock</code>的socket，第二行应改为</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> client <span class="sh_symbol">=</span> net<span class="sh_symbol">.</span><span class="sh_function">connect</span><span class="sh_symbol">(</span><span class="sh_cbracket">{</span>path<span class="sh_symbol">:</span> <span class="sh_string">'/tmp/echo.sock'</span><span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<h2>net.createConnection(path[, connectListener])<span><a class="mark" href="net.html#net_net_createconnection_path_connectlistener" id="net_net_createconnection_path_connectlistener">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_createconnection_path_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_createconnection_path_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>一个生成器函数，返回一个新的 Unix <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 并且自动的
连接到所提供的<code>path</code>参数.</p>
<p><code>connectListener</code>参数将一次被用作监听器来监听<a href="net.html#net_event_connect"><code>'connect'</code></a>事件。</p>
<h2>net.createConnection(port[, host][, connectListener])<span><a class="mark" href="net.html#net_net_createconnection_port_host_connectlistener" id="net_net_createconnection_port_host_connectlistener">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_createconnection_port_host_connectlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_createconnection_port_host_connectlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>一个生成器函数，返回一个新的 Unix <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 并且自动的
连接到所提供的 <code>port</code>和<code>host</code>参数.</p>
<p>如果<code>host</code>被省略，<code>'localhost'</code> 将被默认使用。</p>
<p><code>connectListener</code>参数将一次被用作监听器来监听<a href="net.html#net_event_connect"><code>'connect'</code></a>事件。</p>
<h2>net.createServer([options][, connectionListener])<span><a class="mark" href="net.html#net_net_createserver_options_connectionlistener" id="net_net_createserver_options_connectionlistener">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_createserver_options_connectionlistener">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_createserver_options_connectionlistener.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><p>创建一个新的服务器。<code>connectionListener</code> 参数将一次被用作监听器来监听<a href="net.html#net_event_connection"><code>'connection'</code></a>事件。</p>
<p><code>options</code> 是一个对象，有以下默认属性:</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_cbracket">{</span>
  allowHalfOpen<span class="sh_symbol">:</span> <span class="sh_keyword">false</span><span class="sh_symbol">,</span>
  pauseOnConnect<span class="sh_symbol">:</span> <span class="sh_keyword">false</span>
<span class="sh_cbracket">}</span>
</code></pre>
<p>如果 <code>allowHalfOpen</code> 是 <code>true</code>, 那么socket不会自动的发送一个FIN包，即使socket的另一端
发送了FIN包。socket变成不可读但是可写的。你应该显式地调用 <a href="net.html#net_socket_end_data_encoding"><code>end()</code></a> 方法。
查看 <a href="net.html#net_event_end"><code>'end'</code></a>事件获取更多信息。</p>
<p>如果 <code>pauseOnConnect</code> 是 <code>true</code>, 那么与每个连入的连接的socket将会暂停，
并且不能从其中读取任何数据。这允许将在进程中传递的连接不会被原始进程读取数据。 
为了从暂停的socket中开始读取数据，调用<a href="net.html#net_socket_resume"><code>resume()</code></a>.</p>
<p>下面有关于响应服务器的一个例子，监听连接的8124端口。</p>
<pre class="sh_sourceCode"><code class="lang-js"><span class="sh_keyword">const</span> net <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'net'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">const</span> server <span class="sh_symbol">=</span> net<span class="sh_symbol">.</span><span class="sh_function">createServer</span><span class="sh_symbol">((</span>c<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_comment">// 'connection' listener</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'client connected'</span><span class="sh_symbol">);</span>
  c<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
    console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'client disconnected'</span><span class="sh_symbol">);</span>
  <span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
  c<span class="sh_symbol">.</span><span class="sh_function">write</span><span class="sh_symbol">(</span><span class="sh_string">'hello</span><span class="sh_specialchar">\r\n</span><span class="sh_string">'</span><span class="sh_symbol">);</span>
  c<span class="sh_symbol">.</span><span class="sh_function">pipe</span><span class="sh_symbol">(</span>c<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
server<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'error'</span><span class="sh_symbol">,</span> <span class="sh_symbol">(</span>err<span class="sh_symbol">)</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">throw</span> err<span class="sh_symbol">;</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
server<span class="sh_symbol">.</span><span class="sh_function">listen</span><span class="sh_symbol">(</span><span class="sh_number">8124</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'server bound'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>通过<code>telnet</code>来进行测试:</p>
<pre class="sh_sourceCode"><code class="lang-sh">telnet localhost <span class="sh_number">8124</span>
</code></pre>
<p>为了监听 <code>/tmp/echo.sock</code>socket，从倒数第三行起，应改为</p>
<pre class="sh_sourceCode"><code class="lang-js">server<span class="sh_symbol">.</span><span class="sh_function">listen</span><span class="sh_symbol">(</span><span class="sh_string">'/tmp/echo.sock'</span><span class="sh_symbol">,</span> <span class="sh_symbol">()</span> <span class="sh_symbol">=&gt;</span> <span class="sh_cbracket">{</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'server bound'</span><span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>
</code></pre>
<p>用<code>nc</code> 来连接UNIX域socket服务器:</p>
<pre class="sh_sourceCode"><code class="lang-js">nc <span class="sh_symbol">-</span><span class="sh_normal">U </span><span class="sh_symbol">/</span><span class="sh_normal">tmp</span><span class="sh_symbol">/</span>echo<span class="sh_symbol">.</span>sock
</code></pre>
<h2>net.isIP(input)<span><a class="mark" href="net.html#net_net_isip_input" id="net_net_isip_input">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_isip_input">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_isip_input.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div><p>测试输入是否是IP地址。如果是非法字符串，返回0；
如果是IPv4地址，返回4，如果是IPv6地址，返回6.</p>
<h2>net.isIPv4(input)<span><a class="mark" href="net.html#net_net_isipv4_input" id="net_net_isipv4_input">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_isipv4_input">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_isipv4_input.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div><p>如果输入是IPv4地址的话，返回true, 否则返回false。</p>
<h2>net.isIPv6(input)<span><a class="mark" href="net.html#net_net_isipv6_input" id="net_net_isipv6_input">#</a></span></h2><p style="font-size:12px;margin-top:-1em"><a href="en/net.html#net_net_isipv6_input">查看英文版</a> / <a rel="nofollow" target="_blank" href="https://github.com/nodejscn/node-api-cn/edit/master/net/net_isipv6_input.md">参与翻译</a></p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div><p>如果输入是IPv6地址的话，返回true, 否则返回false。</p>

      </div>
    </div>
 </div>
  <script src="res/api.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>

</body></html>